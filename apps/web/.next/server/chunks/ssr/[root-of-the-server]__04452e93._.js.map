{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/lib/actions/media.actions.ts"],"sourcesContent":["// src/lib/actions/media.actions.ts\r\n'use server';\r\n\r\nimport { createClient } from '@repo/supabase/server';\r\nimport { useCredits } from '@/lib/credits';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { MediaType, CREDIT_COSTS, GenerationResult, GenerationMode } from '@/lib/constants/media';\r\n// Import the specific Insert type and GeneratedMedia type\r\nimport { Database, GeneratedMedia } from '@/types/db_types';\r\nimport { supabaseAdmin } from '@repo/supabase/admin';\r\n// Import only the necessary storage service functions (used by actions below)\r\nimport { listUserFiles as listUserFilesService, deleteFile as deleteFileService } from '@/lib/storage/supabase-storage';\r\n// Import Pixio API client and models\r\nimport {\r\n  PIXIO_MODELS,\r\n  queuePixioRun,\r\n  cancelPixioRun,\r\n  createRunRequest,\r\n  type KreaFluxInputs,\r\n  type WanFirstLastFrameInputs\r\n} from '@repo/pixio-api';\r\n\r\n// Define the specific type for insertion, derived from db_types.ts\r\ntype GeneratedMediaInsert = Database['public']['Tables']['generated_media']['Insert'];\r\n\r\n/**\r\n * Initiates media generation by creating a record and invoking the Supabase Function.\r\n * Expects image URLs for modes that require input images (client handles upload).\r\n */\r\nexport async function generateMedia(formData: FormData): Promise<{\r\n  success: boolean;\r\n  mediaId?: string;\r\n  error?: string;\r\n}> {\r\n  const supabase = await createClient();\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n\r\n  if (!user || userError) {\r\n    return { success: false, error: 'Authentication error' };\r\n  }\r\n\r\n  // --- Read data from FormData ---\r\n  const generationMode = formData.get('generationMode') as GenerationMode;\r\n  \r\n  // Determine media type based on model category, not generation mode name\r\n  const mediaType: MediaType = generationMode === 'firstLastFrameVideo' ? 'video' : 'image';\r\n  // Krea Flux (image mode) → image\r\n  // Qwen Edit (video mode) → image (it's editing, not generating video)\r\n  // Wan 2.2 (firstLastFrameVideo mode) → video\r\n\r\n  // --- Validation ---\r\n  if (!generationMode) {\r\n    return { success: false, error: 'Missing required fields' };\r\n  }\r\n\r\n  // Mode-specific input extraction and validation\r\n  let prompt = '';\r\n  let startImageUrl: string | null = null;\r\n  let endImageUrl: string | null = null;\r\n  let image1Url: string | null = null;\r\n  let image2Url: string | null = null;\r\n  let image3Url: string | null = null;\r\n  let positivePrompt = '';\r\n  let negativePrompt = '';\r\n  let width = 1024;\r\n  let height = 1024;\r\n  let videoWidth = 512;\r\n  let videoHeight = 512;\r\n  let videoLength = 81;\r\n\r\n  if (generationMode === 'image') {\r\n    // Krea Flux\r\n    prompt = formData.get('prompt') as string;\r\n    width = parseInt(formData.get('width') as string) || 1024;\r\n    height = parseInt(formData.get('height') as string) || 1024;\r\n    if (!prompt?.trim()) return { success: false, error: 'Missing prompt' };\r\n  } else if (generationMode === 'video') {\r\n    // Qwen Edit\r\n    image1Url = formData.get('image1Url') as string;\r\n    image2Url = formData.get('image2Url') as string || null;\r\n    image3Url = formData.get('image3Url') as string || null;\r\n    positivePrompt = formData.get('positivePrompt') as string || '';\r\n    negativePrompt = formData.get('negativePrompt') as string || '';\r\n    if (!image1Url) return { success: false, error: 'Missing image for editing' };\r\n  } else if (generationMode === 'firstLastFrameVideo') {\r\n    // Wan 2.2\r\n    prompt = formData.get('prompt') as string;\r\n    startImageUrl = formData.get('startImageUrl') as string;\r\n    endImageUrl = formData.get('endImageUrl') as string;\r\n    videoWidth = parseInt(formData.get('width') as string) || 512;\r\n    videoHeight = parseInt(formData.get('height') as string) || 512;\r\n    videoLength = parseInt(formData.get('length') as string) || 81;\r\n    if (!prompt?.trim()) return { success: false, error: 'Missing prompt' };\r\n    if (!startImageUrl) return { success: false, error: 'Missing start image URL' };\r\n    if (!endImageUrl) return { success: false, error: 'Missing end image URL' };\r\n  }\r\n\r\n  const creditCost = CREDIT_COSTS[generationMode];\r\n  if (creditCost === undefined) {\r\n    return { success: false, error: 'Invalid generation mode' };\r\n  }\r\n\r\n  try {\r\n    // 1. Check and deduct credits\r\n    const creditSuccess = await useCredits(\r\n      user.id,\r\n      creditCost,\r\n      `Generate ${generationMode}: \"${prompt.slice(0, 30)}${prompt.length > 30 ? '...' : ''}\"`\r\n    );\r\n    if (!creditSuccess) { return { success: false, error: 'Not enough credits' }; }\r\n    console.log(`[Action] Credits deducted successfully for user ${user.id}`);\r\n\r\n    // 2. Create initial 'pending' record in DB\r\n    const insertPayload: GeneratedMediaInsert = {\r\n        user_id: user.id,\r\n        prompt: prompt || positivePrompt || 'Image edit', // Use appropriate prompt\r\n        media_type: mediaType,\r\n        credits_used: creditCost,\r\n        status: 'pending',\r\n        media_url: '', // Required by Insert type\r\n        storage_path: '', // Required by Insert type\r\n        metadata: {\r\n          generationMode,\r\n          ...(generationMode === 'image' && { width, height }),\r\n          ...(positivePrompt && { positivePrompt, negativePrompt })\r\n        }\r\n    };\r\n    if (generationMode === 'firstLastFrameVideo') {\r\n        insertPayload.start_image_url = startImageUrl;\r\n        insertPayload.end_image_url = endImageUrl;\r\n    }\r\n    const { data: newMediaRecord, error: insertError } = await supabaseAdmin\r\n      .from('generated_media').insert(insertPayload).select('id').single();\r\n    if (insertError || !newMediaRecord) {\r\n      console.error(\"[Action] Failed to insert initial media record:\", insertError);\r\n      // TODO: Consider refunding credits here if insert fails after deduction\r\n      return { success: false, error: `Failed to create generation record: ${insertError?.message}` };\r\n    }\r\n    const mediaId = newMediaRecord.id;\r\n    console.log(`[Action] Initial media record created with ID: ${mediaId}`);\r\n\r\n    // 3. Prepare webhook URL for Pixio API callbacks\r\n    const webhookUrl = `${process.env.NEXT_PUBLIC_SITE_URL}/api/webhooks/pixio`;\r\n    console.log(`[Action] Using webhook URL: ${webhookUrl}`);\r\n\r\n    // 4. Get API key\r\n    const apiKey = process.env.PIXIO_DEPLOY_API_KEY;\r\n    if (!apiKey) {\r\n      console.error('[Action] PIXIO_DEPLOY_API_KEY not configured');\r\n      return { success: false, error: 'API key not configured' };\r\n    }\r\n\r\n    // 5. Select model and call Pixio API based on generation mode\r\n    let pixioResult;\r\n    let selectedModel;\r\n\r\n    if (generationMode === 'image') {\r\n      // Use Krea Flux model\r\n      selectedModel = PIXIO_MODELS.kreaFlux;\r\n      const inputs: KreaFluxInputs = {\r\n        text: prompt,\r\n        width,\r\n        height\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else if (generationMode === 'video') {\r\n      // Use Qwen Edit model\r\n      selectedModel = PIXIO_MODELS.qwenEdit;\r\n      const inputs: import('@repo/pixio-api').QwenEditInputs = {\r\n        image1: image1Url!,\r\n        positive: positivePrompt,\r\n        negative: negativePrompt,\r\n        ...(image2Url && { image2: image2Url }),\r\n        ...(image3Url && { image3: image3Url })\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else if (generationMode === 'firstLastFrameVideo') {\r\n      // Use Wan First/Last Frame model\r\n      selectedModel = PIXIO_MODELS.wanFirstLastFrame;\r\n      const inputs: WanFirstLastFrameInputs = {\r\n        start_image: startImageUrl!,\r\n        end_image: endImageUrl!,\r\n        positive: prompt, // Wan uses 'positive' not 'prompt'\r\n        negative: '',\r\n        width: videoWidth,\r\n        height: videoHeight,\r\n        length: videoLength\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else {\r\n      console.error(`[Action] Unsupported generation mode: ${generationMode}`);\r\n      return { success: false, error: 'Unsupported generation mode' };\r\n    }\r\n\r\n    // 6. Check Pixio API result\r\n\r\n    if (!pixioResult.success || !pixioResult.data) {\r\n      console.error(`[Action] Pixio API error:`, pixioResult.error);\r\n      \r\n      // Update record to failed\r\n      await supabaseAdmin\r\n        .from('generated_media')\r\n        .update({\r\n          status: 'failed',\r\n          metadata: {\r\n            error: pixioResult.error || 'API request failed',\r\n            failed_at: new Date().toISOString()\r\n          }\r\n        })\r\n        .eq('id', mediaId);\r\n      \r\n      return { success: false, error: pixioResult.error || 'API request failed' };\r\n    }\r\n\r\n    const runId = pixioResult.data.run_id;\r\n\r\n    console.log(`[Action] Pixio API run started with ID: ${runId} using model: ${selectedModel.name}`);\r\n\r\n    // 7. Update record with run_id, model info, and processing status\r\n    const { error: runIdUpdateError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .update({\r\n        status: 'processing',\r\n        metadata: {\r\n          run_id: runId,\r\n          generationMode,\r\n          model_id: selectedModel.id,\r\n          model_name: selectedModel.name,\r\n          started_at: new Date().toISOString()\r\n        }\r\n      })\r\n      .eq('id', mediaId);\r\n\r\n    if (runIdUpdateError) {\r\n      console.error(`[Action] Error updating record with run_id:`, runIdUpdateError);\r\n    }\r\n\r\n    // 8. Revalidate path to show processing state\r\n    revalidatePath('/dashboard');\r\n\r\n    // 9. Return success (webhook will handle completion)\r\n    console.log(`[Action] Successfully initiated generation for ${mediaId}`);\r\n    return { success: true, mediaId: mediaId };\r\n\r\n  } catch (error: any) {\r\n    console.error('[Action] Error in generateMedia action:', error);\r\n    // If the error happened before invocation (e.g., credit deduction), return error\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Cancels a running media generation\r\n */\r\nexport async function cancelGeneration(mediaId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  if (!mediaId) {\r\n    return { success: false, error: 'Media ID is required' };\r\n  }\r\n\r\n  const supabase = await createClient();\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n\r\n  if (!user || userError) {\r\n    return { success: false, error: 'Authentication error' };\r\n  }\r\n\r\n  console.log(`[Action] Cancelling generation for mediaId: ${mediaId}`);\r\n\r\n  try {\r\n    // Fetch the media record to verify ownership and get run_id\r\n    const { data: mediaRecord, error: fetchError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .select('id, user_id, status, metadata')\r\n      .eq('id', mediaId)\r\n      .single();\r\n\r\n    if (fetchError || !mediaRecord) {\r\n      console.error(`[Action] Error fetching media ${mediaId}:`, fetchError);\r\n      return { success: false, error: 'Media record not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    if (mediaRecord.user_id !== user.id) {\r\n      console.warn(`[Action] User ${user.id} attempted to cancel media ${mediaId} owned by ${mediaRecord.user_id}`);\r\n      return { success: false, error: 'Permission denied' };\r\n    }\r\n\r\n    // Check if cancellable\r\n    if (!['pending', 'processing'].includes(mediaRecord.status)) {\r\n      return { success: false, error: `Cannot cancel ${mediaRecord.status} generation` };\r\n    }\r\n\r\n    // Get run_id from metadata\r\n    const runId = (mediaRecord.metadata as any)?.run_id;\r\n    \r\n    if (!runId) {\r\n      // No run_id yet, just update status to failed\r\n      console.log(`[Action] No run_id for ${mediaId}, marking as cancelled locally`);\r\n      \r\n      const { error: updateError } = await supabaseAdmin\r\n        .from('generated_media')\r\n        .update({\r\n          status: 'failed',\r\n          metadata: {\r\n            ...(mediaRecord.metadata as object || {}),\r\n            error: 'Cancelled by user',\r\n            cancelled_at: new Date().toISOString()\r\n          }\r\n        })\r\n        .eq('id', mediaId);\r\n\r\n      if (updateError) {\r\n        console.error('[Action] Error updating cancelled status:', updateError);\r\n        return { success: false, error: 'Failed to cancel generation' };\r\n      }\r\n\r\n      revalidatePath('/dashboard');\r\n      return { success: true };\r\n    }\r\n\r\n    // Call Pixio API to cancel the run using the client\r\n    console.log(`[Action] Calling Pixio API to cancel run: ${runId}`);\r\n    \r\n    const apiKey = process.env.PIXIO_DEPLOY_API_KEY;\r\n    if (!apiKey) {\r\n      return { success: false, error: 'API key not configured' };\r\n    }\r\n\r\n    const cancelResult = await cancelPixioRun(runId, apiKey);\r\n\r\n    // Note: Even if the cancel API call fails, we still mark it as cancelled locally\r\n    if (!cancelResult.success) {\r\n      console.warn(`[Action] Pixio cancel API failed: ${cancelResult.error}, but continuing with local cancellation`);\r\n    }\r\n\r\n    // Update database to cancelled/failed status\r\n    const { error: updateError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .update({\r\n        status: 'failed',\r\n        metadata: {\r\n          ...(mediaRecord.metadata as object || {}),\r\n          error: 'Cancelled by user',\r\n          cancelled_at: new Date().toISOString(),\r\n          cancel_api_status: cancelResult.success ? 'success' : 'failed'\r\n        }\r\n      })\r\n      .eq('id', mediaId);\r\n\r\n    if (updateError) {\r\n      console.error('[Action] Error updating cancelled status:', updateError);\r\n      return { success: false, error: 'Failed to update cancellation status' };\r\n    }\r\n\r\n    console.log(`[Action] Successfully cancelled generation ${mediaId}`);\r\n    revalidatePath('/dashboard');\r\n    return { success: true };\r\n\r\n  } catch (error: any) {\r\n    console.error(`[Action] Error cancelling generation ${mediaId}:`, error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Deletes a media item record and its associated file from storage.\r\n */\r\nexport async function deleteMedia(mediaId: string, storagePath: string | null): Promise<{\r\n    success: boolean;\r\n    error?: string;\r\n  }> {\r\n    if (!mediaId) { return { success: false, error: \"Media ID is required.\" }; }\r\n    const supabase = await createClient(); // Use server client to get user\r\n    const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n    if (!user || userError) { return { success: false, error: 'Authentication error' }; }\r\n\r\n    console.log(`[Action] Deleting media ${mediaId} (path: ${storagePath || 'N/A'}) for user ${user.id}`);\r\n    try {\r\n      // Verify ownership using admin client\r\n      const { data: mediaRecord, error: fetchError } = await supabaseAdmin\r\n        .from('generated_media').select('id, user_id, storage_path').eq('id', mediaId).single();\r\n      if (fetchError || !mediaRecord) { console.error(`[Action] Error fetching media ${mediaId} for deletion or not found:`, fetchError); return { success: false, error: 'Media record not found.' }; }\r\n      if (mediaRecord.user_id !== user.id) { console.warn(`[Action] User ${user.id} attempted to delete media ${mediaId} owned by ${mediaRecord.user_id}. Denying.`); return { success: false, error: 'Permission denied.' }; }\r\n\r\n      const actualStoragePath = mediaRecord.storage_path;\r\n\r\n      // Delete from Storage *only if path exists* using the service function\r\n      if (actualStoragePath) {\r\n        console.log(`[Action] Calling service to delete file from storage: ${actualStoragePath}`);\r\n        const { success: deleteSuccess, error: deleteError } = await deleteFileService(actualStoragePath); // Use storage service\r\n        if (!deleteSuccess) { console.error(`[Action] Error deleting file ${actualStoragePath} from storage (continuing):`, deleteError); }\r\n        else { console.log(`[Action] Successfully deleted file ${actualStoragePath} via service.`); }\r\n      } else { console.log(`[Action] No storage path for media ${mediaId}, skipping storage deletion.`); }\r\n\r\n      // Delete from Database using admin client\r\n      console.log(`[Action] Deleting record from database: ${mediaId}`);\r\n      const { error: dbError } = await supabaseAdmin.from('generated_media').delete().eq('id', mediaId);\r\n      if (dbError) { console.error(`[Action] Error deleting record ${mediaId} from database:`, dbError); throw new Error(`Database deletion failed: ${dbError.message}`); }\r\n      console.log(`[Action] Successfully deleted record ${mediaId} from database.`);\r\n\r\n      revalidatePath('/dashboard');\r\n      return { success: true };\r\n    } catch (error: any) {\r\n      console.error(`[Action] Unexpected error during media deletion for ${mediaId}:`, error);\r\n      return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n/**\r\n * Fetches completed and processing media items for the current user.\r\n */\r\nexport async function fetchUserMedia(): Promise<{\r\n  success: boolean;\r\n  media: GeneratedMedia[];\r\n  error?: string;\r\n}> {\r\n  const supabase = await createClient(); // Uses server client\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n  if (!user || userError) { return { success: false, error: 'Authentication error', media: [] }; }\r\n\r\n  try {\r\n    // Use user-context client for RLS\r\n    const { data, error } = await supabase\r\n      .from('generated_media')\r\n      .select('*')\r\n      .eq('user_id', user.id)\r\n      .in('status', ['pending', 'processing', 'completed', 'failed'])\r\n      .order('created_at', { ascending: false })\r\n      .limit(50); // Adjust limit as needed\r\n\r\n    if (error) { throw new Error(`Failed to fetch media: ${error.message}`); }\r\n    return { success: true, media: data || [], error: undefined };\r\n  } catch (error: any) {\r\n    console.error('[Action] Error fetching user media:', error);\r\n    return { success: false, error: error.message, media: [] };\r\n  }\r\n}\r\n\r\n/**\r\n * Server Action to list user's generated images and input images for selection.\r\n */\r\nexport async function listUserImagesForSelection(): Promise<{\r\n    success: boolean;\r\n    images: { value: string; label: string; type: 'generated' | 'input' }[];\r\n    error?: string;\r\n}> {\r\n    const supabase = await createClient(); // Use server client to get user\r\n    const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n    if (!user || userError) { return { success: false, images: [], error: 'Authentication error' }; }\r\n\r\n    try {\r\n        const [generatedResult, inputResult] = await Promise.all([\r\n            // Fetch completed generated images using RLS-enabled client\r\n            supabase\r\n                .from('generated_media')\r\n                .select('id, prompt, media_url')\r\n                .eq('user_id', user.id)\r\n                .eq('media_type', 'image')\r\n                .eq('status', 'completed')\r\n                .not('media_url', 'is', null)\r\n                .order('created_at', { ascending: false })\r\n                .limit(50), // Limit generated images shown\r\n            // Fetch input images using the service function (uses admin client)\r\n            listUserFilesService(user.id, 'inputs')\r\n        ]);\r\n\r\n        const fetchedImages: { value: string; label: string; type: 'generated' | 'input' }[] = [];\r\n\r\n        // Process generated images\r\n        if (generatedResult.error) { console.error(\"[Action] Error fetching generated images:\", generatedResult.error); }\r\n        else if (generatedResult.data) { generatedResult.data.forEach(item => { fetchedImages.push({ value: item.media_url!, label: item.prompt ? `Gen: ${item.prompt.substring(0, 30)}...` : `Generated Image ${item.id.substring(0, 6)}`, type: 'generated', }); }); }\r\n\r\n        // Process input images\r\n        if (!inputResult.success) { console.error(\"[Action] Error fetching input images:\", inputResult.error); }\r\n        else if (inputResult.files) { inputResult.files.forEach(file => { if (file.publicUrl && /\\.(jpg|jpeg|png|webp|gif)$/i.test(file.name)) { fetchedImages.push({ value: file.publicUrl, label: `Input: ${file.name}`, type: 'input', }); } }); }\r\n\r\n        fetchedImages.sort((a, b) => a.label.localeCompare(b.label));\r\n        return { success: true, images: fetchedImages };\r\n\r\n    } catch (error: any) {\r\n        console.error('[Action] Error listing user images:', error);\r\n        return { success: false, images: [], error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;IA6BsB,gBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/lib/actions/media.actions.ts"],"sourcesContent":["// src/lib/actions/media.actions.ts\r\n'use server';\r\n\r\nimport { createClient } from '@repo/supabase/server';\r\nimport { useCredits } from '@/lib/credits';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { MediaType, CREDIT_COSTS, GenerationResult, GenerationMode } from '@/lib/constants/media';\r\n// Import the specific Insert type and GeneratedMedia type\r\nimport { Database, GeneratedMedia } from '@/types/db_types';\r\nimport { supabaseAdmin } from '@repo/supabase/admin';\r\n// Import only the necessary storage service functions (used by actions below)\r\nimport { listUserFiles as listUserFilesService, deleteFile as deleteFileService } from '@/lib/storage/supabase-storage';\r\n// Import Pixio API client and models\r\nimport {\r\n  PIXIO_MODELS,\r\n  queuePixioRun,\r\n  cancelPixioRun,\r\n  createRunRequest,\r\n  type KreaFluxInputs,\r\n  type WanFirstLastFrameInputs\r\n} from '@repo/pixio-api';\r\n\r\n// Define the specific type for insertion, derived from db_types.ts\r\ntype GeneratedMediaInsert = Database['public']['Tables']['generated_media']['Insert'];\r\n\r\n/**\r\n * Initiates media generation by creating a record and invoking the Supabase Function.\r\n * Expects image URLs for modes that require input images (client handles upload).\r\n */\r\nexport async function generateMedia(formData: FormData): Promise<{\r\n  success: boolean;\r\n  mediaId?: string;\r\n  error?: string;\r\n}> {\r\n  const supabase = await createClient();\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n\r\n  if (!user || userError) {\r\n    return { success: false, error: 'Authentication error' };\r\n  }\r\n\r\n  // --- Read data from FormData ---\r\n  const generationMode = formData.get('generationMode') as GenerationMode;\r\n  \r\n  // Determine media type based on model category, not generation mode name\r\n  const mediaType: MediaType = generationMode === 'firstLastFrameVideo' ? 'video' : 'image';\r\n  // Krea Flux (image mode) → image\r\n  // Qwen Edit (video mode) → image (it's editing, not generating video)\r\n  // Wan 2.2 (firstLastFrameVideo mode) → video\r\n\r\n  // --- Validation ---\r\n  if (!generationMode) {\r\n    return { success: false, error: 'Missing required fields' };\r\n  }\r\n\r\n  // Mode-specific input extraction and validation\r\n  let prompt = '';\r\n  let startImageUrl: string | null = null;\r\n  let endImageUrl: string | null = null;\r\n  let image1Url: string | null = null;\r\n  let image2Url: string | null = null;\r\n  let image3Url: string | null = null;\r\n  let positivePrompt = '';\r\n  let negativePrompt = '';\r\n  let width = 1024;\r\n  let height = 1024;\r\n  let videoWidth = 512;\r\n  let videoHeight = 512;\r\n  let videoLength = 81;\r\n\r\n  if (generationMode === 'image') {\r\n    // Krea Flux\r\n    prompt = formData.get('prompt') as string;\r\n    width = parseInt(formData.get('width') as string) || 1024;\r\n    height = parseInt(formData.get('height') as string) || 1024;\r\n    if (!prompt?.trim()) return { success: false, error: 'Missing prompt' };\r\n  } else if (generationMode === 'video') {\r\n    // Qwen Edit\r\n    image1Url = formData.get('image1Url') as string;\r\n    image2Url = formData.get('image2Url') as string || null;\r\n    image3Url = formData.get('image3Url') as string || null;\r\n    positivePrompt = formData.get('positivePrompt') as string || '';\r\n    negativePrompt = formData.get('negativePrompt') as string || '';\r\n    if (!image1Url) return { success: false, error: 'Missing image for editing' };\r\n  } else if (generationMode === 'firstLastFrameVideo') {\r\n    // Wan 2.2\r\n    prompt = formData.get('prompt') as string;\r\n    startImageUrl = formData.get('startImageUrl') as string;\r\n    endImageUrl = formData.get('endImageUrl') as string;\r\n    videoWidth = parseInt(formData.get('width') as string) || 512;\r\n    videoHeight = parseInt(formData.get('height') as string) || 512;\r\n    videoLength = parseInt(formData.get('length') as string) || 81;\r\n    if (!prompt?.trim()) return { success: false, error: 'Missing prompt' };\r\n    if (!startImageUrl) return { success: false, error: 'Missing start image URL' };\r\n    if (!endImageUrl) return { success: false, error: 'Missing end image URL' };\r\n  }\r\n\r\n  const creditCost = CREDIT_COSTS[generationMode];\r\n  if (creditCost === undefined) {\r\n    return { success: false, error: 'Invalid generation mode' };\r\n  }\r\n\r\n  try {\r\n    // 1. Check and deduct credits\r\n    const creditSuccess = await useCredits(\r\n      user.id,\r\n      creditCost,\r\n      `Generate ${generationMode}: \"${prompt.slice(0, 30)}${prompt.length > 30 ? '...' : ''}\"`\r\n    );\r\n    if (!creditSuccess) { return { success: false, error: 'Not enough credits' }; }\r\n    console.log(`[Action] Credits deducted successfully for user ${user.id}`);\r\n\r\n    // 2. Create initial 'pending' record in DB\r\n    const insertPayload: GeneratedMediaInsert = {\r\n        user_id: user.id,\r\n        prompt: prompt || positivePrompt || 'Image edit', // Use appropriate prompt\r\n        media_type: mediaType,\r\n        credits_used: creditCost,\r\n        status: 'pending',\r\n        media_url: '', // Required by Insert type\r\n        storage_path: '', // Required by Insert type\r\n        metadata: {\r\n          generationMode,\r\n          ...(generationMode === 'image' && { width, height }),\r\n          ...(positivePrompt && { positivePrompt, negativePrompt })\r\n        }\r\n    };\r\n    if (generationMode === 'firstLastFrameVideo') {\r\n        insertPayload.start_image_url = startImageUrl;\r\n        insertPayload.end_image_url = endImageUrl;\r\n    }\r\n    const { data: newMediaRecord, error: insertError } = await supabaseAdmin\r\n      .from('generated_media').insert(insertPayload).select('id').single();\r\n    if (insertError || !newMediaRecord) {\r\n      console.error(\"[Action] Failed to insert initial media record:\", insertError);\r\n      // TODO: Consider refunding credits here if insert fails after deduction\r\n      return { success: false, error: `Failed to create generation record: ${insertError?.message}` };\r\n    }\r\n    const mediaId = newMediaRecord.id;\r\n    console.log(`[Action] Initial media record created with ID: ${mediaId}`);\r\n\r\n    // 3. Prepare webhook URL for Pixio API callbacks\r\n    const webhookUrl = `${process.env.NEXT_PUBLIC_SITE_URL}/api/webhooks/pixio`;\r\n    console.log(`[Action] Using webhook URL: ${webhookUrl}`);\r\n\r\n    // 4. Get API key\r\n    const apiKey = process.env.PIXIO_DEPLOY_API_KEY;\r\n    if (!apiKey) {\r\n      console.error('[Action] PIXIO_DEPLOY_API_KEY not configured');\r\n      return { success: false, error: 'API key not configured' };\r\n    }\r\n\r\n    // 5. Select model and call Pixio API based on generation mode\r\n    let pixioResult;\r\n    let selectedModel;\r\n\r\n    if (generationMode === 'image') {\r\n      // Use Krea Flux model\r\n      selectedModel = PIXIO_MODELS.kreaFlux;\r\n      const inputs: KreaFluxInputs = {\r\n        text: prompt,\r\n        width,\r\n        height\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else if (generationMode === 'video') {\r\n      // Use Qwen Edit model\r\n      selectedModel = PIXIO_MODELS.qwenEdit;\r\n      const inputs: import('@repo/pixio-api').QwenEditInputs = {\r\n        image1: image1Url!,\r\n        positive: positivePrompt,\r\n        negative: negativePrompt,\r\n        ...(image2Url && { image2: image2Url }),\r\n        ...(image3Url && { image3: image3Url })\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else if (generationMode === 'firstLastFrameVideo') {\r\n      // Use Wan First/Last Frame model\r\n      selectedModel = PIXIO_MODELS.wanFirstLastFrame;\r\n      const inputs: WanFirstLastFrameInputs = {\r\n        start_image: startImageUrl!,\r\n        end_image: endImageUrl!,\r\n        positive: prompt, // Wan uses 'positive' not 'prompt'\r\n        negative: '',\r\n        width: videoWidth,\r\n        height: videoHeight,\r\n        length: videoLength\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else {\r\n      console.error(`[Action] Unsupported generation mode: ${generationMode}`);\r\n      return { success: false, error: 'Unsupported generation mode' };\r\n    }\r\n\r\n    // 6. Check Pixio API result\r\n\r\n    if (!pixioResult.success || !pixioResult.data) {\r\n      console.error(`[Action] Pixio API error:`, pixioResult.error);\r\n      \r\n      // Update record to failed\r\n      await supabaseAdmin\r\n        .from('generated_media')\r\n        .update({\r\n          status: 'failed',\r\n          metadata: {\r\n            error: pixioResult.error || 'API request failed',\r\n            failed_at: new Date().toISOString()\r\n          }\r\n        })\r\n        .eq('id', mediaId);\r\n      \r\n      return { success: false, error: pixioResult.error || 'API request failed' };\r\n    }\r\n\r\n    const runId = pixioResult.data.run_id;\r\n\r\n    console.log(`[Action] Pixio API run started with ID: ${runId} using model: ${selectedModel.name}`);\r\n\r\n    // 7. Update record with run_id, model info, and processing status\r\n    const { error: runIdUpdateError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .update({\r\n        status: 'processing',\r\n        metadata: {\r\n          run_id: runId,\r\n          generationMode,\r\n          model_id: selectedModel.id,\r\n          model_name: selectedModel.name,\r\n          started_at: new Date().toISOString()\r\n        }\r\n      })\r\n      .eq('id', mediaId);\r\n\r\n    if (runIdUpdateError) {\r\n      console.error(`[Action] Error updating record with run_id:`, runIdUpdateError);\r\n    }\r\n\r\n    // 8. Revalidate path to show processing state\r\n    revalidatePath('/dashboard');\r\n\r\n    // 9. Return success (webhook will handle completion)\r\n    console.log(`[Action] Successfully initiated generation for ${mediaId}`);\r\n    return { success: true, mediaId: mediaId };\r\n\r\n  } catch (error: any) {\r\n    console.error('[Action] Error in generateMedia action:', error);\r\n    // If the error happened before invocation (e.g., credit deduction), return error\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Cancels a running media generation\r\n */\r\nexport async function cancelGeneration(mediaId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  if (!mediaId) {\r\n    return { success: false, error: 'Media ID is required' };\r\n  }\r\n\r\n  const supabase = await createClient();\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n\r\n  if (!user || userError) {\r\n    return { success: false, error: 'Authentication error' };\r\n  }\r\n\r\n  console.log(`[Action] Cancelling generation for mediaId: ${mediaId}`);\r\n\r\n  try {\r\n    // Fetch the media record to verify ownership and get run_id\r\n    const { data: mediaRecord, error: fetchError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .select('id, user_id, status, metadata')\r\n      .eq('id', mediaId)\r\n      .single();\r\n\r\n    if (fetchError || !mediaRecord) {\r\n      console.error(`[Action] Error fetching media ${mediaId}:`, fetchError);\r\n      return { success: false, error: 'Media record not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    if (mediaRecord.user_id !== user.id) {\r\n      console.warn(`[Action] User ${user.id} attempted to cancel media ${mediaId} owned by ${mediaRecord.user_id}`);\r\n      return { success: false, error: 'Permission denied' };\r\n    }\r\n\r\n    // Check if cancellable\r\n    if (!['pending', 'processing'].includes(mediaRecord.status)) {\r\n      return { success: false, error: `Cannot cancel ${mediaRecord.status} generation` };\r\n    }\r\n\r\n    // Get run_id from metadata\r\n    const runId = (mediaRecord.metadata as any)?.run_id;\r\n    \r\n    if (!runId) {\r\n      // No run_id yet, just update status to failed\r\n      console.log(`[Action] No run_id for ${mediaId}, marking as cancelled locally`);\r\n      \r\n      const { error: updateError } = await supabaseAdmin\r\n        .from('generated_media')\r\n        .update({\r\n          status: 'failed',\r\n          metadata: {\r\n            ...(mediaRecord.metadata as object || {}),\r\n            error: 'Cancelled by user',\r\n            cancelled_at: new Date().toISOString()\r\n          }\r\n        })\r\n        .eq('id', mediaId);\r\n\r\n      if (updateError) {\r\n        console.error('[Action] Error updating cancelled status:', updateError);\r\n        return { success: false, error: 'Failed to cancel generation' };\r\n      }\r\n\r\n      revalidatePath('/dashboard');\r\n      return { success: true };\r\n    }\r\n\r\n    // Call Pixio API to cancel the run using the client\r\n    console.log(`[Action] Calling Pixio API to cancel run: ${runId}`);\r\n    \r\n    const apiKey = process.env.PIXIO_DEPLOY_API_KEY;\r\n    if (!apiKey) {\r\n      return { success: false, error: 'API key not configured' };\r\n    }\r\n\r\n    const cancelResult = await cancelPixioRun(runId, apiKey);\r\n\r\n    // Note: Even if the cancel API call fails, we still mark it as cancelled locally\r\n    if (!cancelResult.success) {\r\n      console.warn(`[Action] Pixio cancel API failed: ${cancelResult.error}, but continuing with local cancellation`);\r\n    }\r\n\r\n    // Update database to cancelled/failed status\r\n    const { error: updateError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .update({\r\n        status: 'failed',\r\n        metadata: {\r\n          ...(mediaRecord.metadata as object || {}),\r\n          error: 'Cancelled by user',\r\n          cancelled_at: new Date().toISOString(),\r\n          cancel_api_status: cancelResult.success ? 'success' : 'failed'\r\n        }\r\n      })\r\n      .eq('id', mediaId);\r\n\r\n    if (updateError) {\r\n      console.error('[Action] Error updating cancelled status:', updateError);\r\n      return { success: false, error: 'Failed to update cancellation status' };\r\n    }\r\n\r\n    console.log(`[Action] Successfully cancelled generation ${mediaId}`);\r\n    revalidatePath('/dashboard');\r\n    return { success: true };\r\n\r\n  } catch (error: any) {\r\n    console.error(`[Action] Error cancelling generation ${mediaId}:`, error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Deletes a media item record and its associated file from storage.\r\n */\r\nexport async function deleteMedia(mediaId: string, storagePath: string | null): Promise<{\r\n    success: boolean;\r\n    error?: string;\r\n  }> {\r\n    if (!mediaId) { return { success: false, error: \"Media ID is required.\" }; }\r\n    const supabase = await createClient(); // Use server client to get user\r\n    const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n    if (!user || userError) { return { success: false, error: 'Authentication error' }; }\r\n\r\n    console.log(`[Action] Deleting media ${mediaId} (path: ${storagePath || 'N/A'}) for user ${user.id}`);\r\n    try {\r\n      // Verify ownership using admin client\r\n      const { data: mediaRecord, error: fetchError } = await supabaseAdmin\r\n        .from('generated_media').select('id, user_id, storage_path').eq('id', mediaId).single();\r\n      if (fetchError || !mediaRecord) { console.error(`[Action] Error fetching media ${mediaId} for deletion or not found:`, fetchError); return { success: false, error: 'Media record not found.' }; }\r\n      if (mediaRecord.user_id !== user.id) { console.warn(`[Action] User ${user.id} attempted to delete media ${mediaId} owned by ${mediaRecord.user_id}. Denying.`); return { success: false, error: 'Permission denied.' }; }\r\n\r\n      const actualStoragePath = mediaRecord.storage_path;\r\n\r\n      // Delete from Storage *only if path exists* using the service function\r\n      if (actualStoragePath) {\r\n        console.log(`[Action] Calling service to delete file from storage: ${actualStoragePath}`);\r\n        const { success: deleteSuccess, error: deleteError } = await deleteFileService(actualStoragePath); // Use storage service\r\n        if (!deleteSuccess) { console.error(`[Action] Error deleting file ${actualStoragePath} from storage (continuing):`, deleteError); }\r\n        else { console.log(`[Action] Successfully deleted file ${actualStoragePath} via service.`); }\r\n      } else { console.log(`[Action] No storage path for media ${mediaId}, skipping storage deletion.`); }\r\n\r\n      // Delete from Database using admin client\r\n      console.log(`[Action] Deleting record from database: ${mediaId}`);\r\n      const { error: dbError } = await supabaseAdmin.from('generated_media').delete().eq('id', mediaId);\r\n      if (dbError) { console.error(`[Action] Error deleting record ${mediaId} from database:`, dbError); throw new Error(`Database deletion failed: ${dbError.message}`); }\r\n      console.log(`[Action] Successfully deleted record ${mediaId} from database.`);\r\n\r\n      revalidatePath('/dashboard');\r\n      return { success: true };\r\n    } catch (error: any) {\r\n      console.error(`[Action] Unexpected error during media deletion for ${mediaId}:`, error);\r\n      return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n/**\r\n * Fetches completed and processing media items for the current user.\r\n */\r\nexport async function fetchUserMedia(): Promise<{\r\n  success: boolean;\r\n  media: GeneratedMedia[];\r\n  error?: string;\r\n}> {\r\n  const supabase = await createClient(); // Uses server client\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n  if (!user || userError) { return { success: false, error: 'Authentication error', media: [] }; }\r\n\r\n  try {\r\n    // Use user-context client for RLS\r\n    const { data, error } = await supabase\r\n      .from('generated_media')\r\n      .select('*')\r\n      .eq('user_id', user.id)\r\n      .in('status', ['pending', 'processing', 'completed', 'failed'])\r\n      .order('created_at', { ascending: false })\r\n      .limit(50); // Adjust limit as needed\r\n\r\n    if (error) { throw new Error(`Failed to fetch media: ${error.message}`); }\r\n    return { success: true, media: data || [], error: undefined };\r\n  } catch (error: any) {\r\n    console.error('[Action] Error fetching user media:', error);\r\n    return { success: false, error: error.message, media: [] };\r\n  }\r\n}\r\n\r\n/**\r\n * Server Action to list user's generated images and input images for selection.\r\n */\r\nexport async function listUserImagesForSelection(): Promise<{\r\n    success: boolean;\r\n    images: { value: string; label: string; type: 'generated' | 'input' }[];\r\n    error?: string;\r\n}> {\r\n    const supabase = await createClient(); // Use server client to get user\r\n    const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n    if (!user || userError) { return { success: false, images: [], error: 'Authentication error' }; }\r\n\r\n    try {\r\n        const [generatedResult, inputResult] = await Promise.all([\r\n            // Fetch completed generated images using RLS-enabled client\r\n            supabase\r\n                .from('generated_media')\r\n                .select('id, prompt, media_url')\r\n                .eq('user_id', user.id)\r\n                .eq('media_type', 'image')\r\n                .eq('status', 'completed')\r\n                .not('media_url', 'is', null)\r\n                .order('created_at', { ascending: false })\r\n                .limit(50), // Limit generated images shown\r\n            // Fetch input images using the service function (uses admin client)\r\n            listUserFilesService(user.id, 'inputs')\r\n        ]);\r\n\r\n        const fetchedImages: { value: string; label: string; type: 'generated' | 'input' }[] = [];\r\n\r\n        // Process generated images\r\n        if (generatedResult.error) { console.error(\"[Action] Error fetching generated images:\", generatedResult.error); }\r\n        else if (generatedResult.data) { generatedResult.data.forEach(item => { fetchedImages.push({ value: item.media_url!, label: item.prompt ? `Gen: ${item.prompt.substring(0, 30)}...` : `Generated Image ${item.id.substring(0, 6)}`, type: 'generated', }); }); }\r\n\r\n        // Process input images\r\n        if (!inputResult.success) { console.error(\"[Action] Error fetching input images:\", inputResult.error); }\r\n        else if (inputResult.files) { inputResult.files.forEach(file => { if (file.publicUrl && /\\.(jpg|jpeg|png|webp|gif)$/i.test(file.name)) { fetchedImages.push({ value: file.publicUrl, label: `Input: ${file.name}`, type: 'input', }); } }); }\r\n\r\n        fetchedImages.sort((a, b) => a.label.localeCompare(b.label));\r\n        return { success: true, images: fetchedImages };\r\n\r\n    } catch (error: any) {\r\n        console.error('[Action] Error listing user images:', error);\r\n        return { success: false, images: [], error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;IAidsB,6BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/components/dashboard/image-selector-popover.tsx"],"sourcesContent":["// src/components/dashboard/image-selector-popover.tsx\r\n'use client';\r\n\r\nimport * as React from \"react\";\r\nimport { Check, ChevronsUpDown, Loader2 } from \"lucide-react\";\r\nimport { cn } from \"@repo/ui/utils\";\r\nimport { Button } from \"@repo/ui\";\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n  CommandSeparator,\r\n} from \"@repo/ui\";\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from \"@repo/ui\";\r\n// Import the NEW server action\r\nimport { listUserImagesForSelection } from \"@/lib/actions/media.actions\";\r\nimport NextImage from \"next/image\";\r\nimport { toast } from \"sonner\"; // Import toast for error handling\r\n\r\ninterface ImageOption {\r\n  value: string; // URL\r\n  label: string; // Filename or prompt\r\n  type: 'generated' | 'input';\r\n}\r\n\r\ninterface ImageSelectorPopoverProps {\r\n  selectedUrl: string | null;\r\n  onImageSelect: (url: string | null) => void;\r\n  triggerText?: string;\r\n  disabled?: boolean;\r\n}\r\n\r\nexport function ImageSelectorPopover({\r\n  selectedUrl,\r\n  onImageSelect,\r\n  triggerText = \"Select Image\",\r\n  disabled = false,\r\n}: ImageSelectorPopoverProps) {\r\n  const [open, setOpen] = React.useState(false);\r\n  const [loading, setLoading] = React.useState(false);\r\n  const [images, setImages] = React.useState<ImageOption[]>([]);\r\n  const hasFetched = React.useRef(false); // Track if fetch has been attempted\r\n\r\n  // Fetch images when popover opens\r\n  React.useEffect(() => {\r\n    // Only fetch if popover is open AND fetch hasn't been attempted yet\r\n    if (open && !hasFetched.current) {\r\n      const fetchImages = async () => {\r\n        setLoading(true);\r\n        hasFetched.current = true; // Mark fetch as attempted\r\n        try {\r\n          // Call the SERVER ACTION\r\n          const result = await listUserImagesForSelection();\r\n\r\n          if (result.success) {\r\n            setImages(result.images);\r\n          } else {\r\n            console.error(\"Failed to fetch images:\", result.error);\r\n            toast.error(\"Could not load existing images.\");\r\n            setImages([]); // Clear images on error\r\n          }\r\n        } catch (error) {\r\n          console.error(\"Error calling listUserImagesForSelection:\", error);\r\n          toast.error(\"An error occurred while loading images.\");\r\n          setImages([]); // Clear images on error\r\n        } finally {\r\n          setLoading(false);\r\n        }\r\n      };\r\n      fetchImages();\r\n    } else if (!open) {\r\n        // Reset fetch tracker when popover closes, allowing refetch next time\r\n        hasFetched.current = false;\r\n    }\r\n  }, [open]); // Depend only on open state\r\n\r\n  const selectedLabel = images.find((image) => image.value === selectedUrl)?.label;\r\n\r\n  return (\r\n    <Popover open={open} onOpenChange={setOpen}>\r\n      <PopoverTrigger asChild>\r\n        <Button\r\n          variant=\"outline\"\r\n          role=\"combobox\"\r\n          aria-expanded={open}\r\n          className=\"w-1/2 justify-between glass-input bg-white/5 border-white/15 hover:bg-white/10 text-foreground/80\"\r\n          disabled={disabled}\r\n          title={selectedLabel ?? triggerText}\r\n        >\r\n          <span className=\"truncate\">\r\n            {selectedUrl && selectedLabel\r\n              ? selectedLabel\r\n              : triggerText}\r\n          </span>\r\n          <ChevronsUpDown className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" />\r\n        </Button>\r\n      </PopoverTrigger>\r\n      <PopoverContent className=\"w-[--radix-popover-trigger-width] max-h-[--radix-popover-content-available-height] p-0 glass-card\">\r\n        <Command>\r\n          <CommandInput placeholder=\"Search images...\" />\r\n          <CommandList>\r\n            {loading ? (\r\n              <div className=\"py-6 text-center text-sm flex items-center justify-center gap-2 text-muted-foreground\">\r\n                <Loader2 className=\"h-4 w-4 animate-spin\" /> Loading images...\r\n              </div>\r\n            ) : (\r\n              <>\r\n                <CommandEmpty>No images found.</CommandEmpty>\r\n                {/* Group for Input Images */}\r\n                {images.some(img => img.type === 'input') && (\r\n                    <CommandGroup heading=\"Uploaded Inputs\">\r\n                      {images.filter(img => img.type === 'input').map((image) => (\r\n                        <CommandItem\r\n                          key={image.value}\r\n                          value={image.label}\r\n                          onSelect={() => {\r\n                            onImageSelect(image.value === selectedUrl ? null : image.value);\r\n                            setOpen(false);\r\n                          }}\r\n                          className=\"flex items-center gap-2 cursor-pointer\"\r\n                        >\r\n                          <NextImage src={image.value} alt={image.label} width={24} height={24} className=\"h-6 w-6 rounded object-cover flex-shrink-0 border border-white/10\" />\r\n                          <span className=\"truncate flex-grow\">{image.label}</span>\r\n                          <Check className={cn(\"ml-auto h-4 w-4\", selectedUrl === image.value ? \"opacity-100\" : \"opacity-0\")} />\r\n                        </CommandItem>\r\n                      ))}\r\n                    </CommandGroup>\r\n                )}\r\n                {/* Separator if both groups exist */}\r\n                {images.some(img => img.type === 'input') && images.some(img => img.type === 'generated') && (\r\n                    <CommandSeparator />\r\n                )}\r\n                {/* Group for Generated Images */}\r\n                {images.some(img => img.type === 'generated') && (\r\n                    <CommandGroup heading=\"Generated Images\">\r\n                      {images.filter(img => img.type === 'generated').map((image) => (\r\n                        <CommandItem\r\n                          key={image.value}\r\n                          value={image.label}\r\n                          onSelect={() => {\r\n                            onImageSelect(image.value === selectedUrl ? null : image.value);\r\n                            setOpen(false);\r\n                          }}\r\n                          className=\"flex items-center gap-2 cursor-pointer\"\r\n                        >\r\n                          <NextImage src={image.value} alt={image.label} width={24} height={24} className=\"h-6 w-6 rounded object-cover flex-shrink-0 border border-white/10\" />\r\n                          <span className=\"truncate flex-grow\">{image.label}</span>\r\n                          <Check className={cn(\"ml-auto h-4 w-4\", selectedUrl === image.value ? \"opacity-100\" : \"opacity-0\")} />\r\n                        </CommandItem>\r\n                      ))}\r\n                    </CommandGroup>\r\n                )}\r\n              </>\r\n            )}\r\n          </CommandList>\r\n        </Command>\r\n      </PopoverContent>\r\n    </Popover>\r\n  );\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 316, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/components/dashboard/media-generation-form.tsx"],"sourcesContent":["// src/components/dashboard/media-generation-form.tsx\r\n'use client';\r\n\r\nimport { useState, useEffect, useRef, useCallback } from 'react';\r\nimport { Button } from '@repo/ui';\r\nimport { Textarea } from '@repo/ui';\r\nimport { Input } from '@repo/ui';\r\nimport { Label } from '@repo/ui';\r\nimport { Loader2, AlertCircle, Image as LucideImage, Film, Sparkles, Upload, X } from 'lucide-react';\r\nimport { generateMedia } from '@/lib/actions/media.actions';\r\nimport { toast } from 'sonner';\r\nimport Image from 'next/image';\r\nimport { MediaType, MediaStatus, GenerationMode, CREDIT_COSTS } from '@/lib/constants/media';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { ImageSelectorPopover } from './image-selector-popover';\r\nimport imageCompression from 'browser-image-compression';\r\n// Import Supabase client\r\nimport { createClient } from '@repo/supabase/client';\r\nimport { v4 as uuidv4 } from 'uuid'; // For unique filenames\r\n\r\ninterface MediaGenerationFormProps {\r\n  generationMode: GenerationMode;\r\n  creditCost: number;\r\n  userCredits: number;\r\n  onGenerationStart?: (mediaId: string) => void;\r\n}\r\n\r\n// Import Pixio models for proper handling\r\nimport { PIXIO_MODELS } from '@repo/pixio-api';\r\n\r\n// Helper function for direct Supabase upload\r\nasync function uploadDirectlyToSupabase(\r\n    file: File,\r\n    userId: string,\r\n    type: 'start' | 'end' | 'image1'\r\n): Promise<{ success: boolean; url?: string; error?: string }> {\r\n    if (!file || !userId) {\r\n        return { success: false, error: 'User ID and file are required.' };\r\n    }\r\n\r\n    const supabase = createClient(); // Initialize Supabase client\r\n\r\n    try {\r\n        const fileExtension = file.name.split('.').pop()?.toLowerCase() || 'bin';\r\n        // Use UUID for more robust uniqueness\r\n        const fileName = `${type}-${uuidv4()}.${fileExtension}`;\r\n        const storagePath = `${userId}/inputs/${fileName}`; // Store in user-specific inputs folder\r\n\r\n        console.log(`Uploading input image directly to: ${storagePath}`);\r\n        const uploadToastId = toast.info(`Uploading ${type} image...`, { duration: 60000 }); // Show toast with longer duration\r\n\r\n        const { data, error: uploadError } = await supabase.storage\r\n            .from('generated-media') // Your bucket name\r\n            .upload(storagePath, file, {\r\n                cacheControl: '3600',\r\n                upsert: false, // Don't upsert, use unique names\r\n                contentType: file.type,\r\n            });\r\n\r\n        toast.dismiss(uploadToastId); // Dismiss upload toast immediately after attempt\r\n\r\n        if (uploadError) {\r\n            console.error(`Direct upload error (${type}):`, uploadError);\r\n            throw new Error(`Direct upload failed: ${uploadError.message}`);\r\n        }\r\n\r\n        // Get public URL\r\n        const { data: publicUrlData } = supabase.storage\r\n            .from('generated-media')\r\n            .getPublicUrl(storagePath);\r\n\r\n        if (!publicUrlData?.publicUrl) {\r\n            throw new Error('Failed to get public URL for uploaded input image.');\r\n        }\r\n\r\n        console.log(`Direct upload success (${type}): ${publicUrlData.publicUrl}`);\r\n        // toast.success(`${type.charAt(0).toUpperCase() + type.slice(1)} image uploaded.`); // Optional success toast\r\n\r\n        return { success: true, url: publicUrlData.publicUrl };\r\n\r\n    } catch (error: any) {\r\n        console.error(`Error in uploadDirectlyToSupabase (${type}):`, error);\r\n        // toast.dismiss(); // Ensure any related toasts are dismissed\r\n        toast.error(`Failed to upload ${type} image.`);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n\r\nexport function MediaGenerationForm({\r\n  generationMode,\r\n  creditCost,\r\n  userCredits,\r\n  onGenerationStart\r\n}: MediaGenerationFormProps) {\r\n  const [prompt, setPrompt] = useState('');\r\n  const [startImageFile, setStartImageFile] = useState<File | null>(null);\r\n  const [endImageFile, setEndImageFile] = useState<File | null>(null);\r\n  const [startImageUrl, setStartImageUrl] = useState<string | null>(null);\r\n  const [endImageUrl, setEndImageUrl] = useState<string | null>(null);\r\n  const [startImagePreview, setStartImagePreview] = useState<string | null>(null);\r\n  const [endImagePreview, setEndImagePreview] = useState<string | null>(null);\r\n  \r\n  // Qwen Edit specific states\r\n  const [image1File, setImage1File] = useState<File | null>(null);\r\n  const [image1Url, setImage1Url] = useState<string | null>(null);\r\n  const [image1Preview, setImage1Preview] = useState<string | null>(null);\r\n  const [image2File, setImage2File] = useState<File | null>(null);\r\n  const [image2Url, setImage2Url] = useState<string | null>(null);\r\n  const [image2Preview, setImage2Preview] = useState<string | null>(null);\r\n  const [image3File, setImage3File] = useState<File | null>(null);\r\n  const [image3Url, setImage3Url] = useState<string | null>(null);\r\n  const [image3Preview, setImage3Preview] = useState<string | null>(null);\r\n  const [positivePrompt, setPositivePrompt] = useState('');\r\n  const [negativePrompt, setNegativePrompt] = useState('');\r\n\r\n  // Krea Flux specific states\r\n  const [width, setWidth] = useState(1024);\r\n  const [height, setHeight] = useState(1024);\r\n\r\n  // Wan 2.2 specific states\r\n  const [videoWidth, setVideoWidth] = useState(512);\r\n  const [videoHeight, setVideoHeight] = useState(512);\r\n  const [videoLength, setVideoLength] = useState(81);\r\n\r\n  const [isSubmitting, setIsSubmitting] = useState(false);\r\n  const [currentMediaId, setCurrentMediaId] = useState<string | null>(null);\r\n  const [previewUrl, setPreviewUrl] = useState<string | null>(null);\r\n  const [previewStatus, setPreviewStatus] = useState<MediaStatus | 'idle'>('idle');\r\n  const startFileInputRef = useRef<HTMLInputElement>(null);\r\n  const endFileInputRef = useRef<HTMLInputElement>(null);\r\n  const image1FileInputRef = useRef<HTMLInputElement>(null);\r\n  const image2FileInputRef = useRef<HTMLInputElement>(null);\r\n  const image3FileInputRef = useRef<HTMLInputElement>(null);\r\n  const [userId, setUserId] = useState<string | null>(null);\r\n\r\n  const supabase = createClient(); // Initialize client for user ID and Realtime\r\n\r\n  // Get user ID on mount\r\n  useEffect(() => {\r\n    const getUser = async () => {\r\n      const { data: { user } } = await supabase.auth.getUser();\r\n      setUserId(user?.id || null);\r\n      if (!user) console.warn(\"MediaGenerationForm: User not found on mount.\");\r\n    };\r\n    getUser();\r\n  }, [supabase]);\r\n\r\n  // Determine actual media type based on model category\r\n  const getMediaType = (): MediaType => {\r\n    if (generationMode === 'image') return 'image'; // Krea Flux → image\r\n    if (generationMode === 'video') return 'image';  // Qwen Edit → image (it's editing, not video generation)\r\n    if (generationMode === 'firstLastFrameVideo') return 'video'; // Wan 2.2 → video\r\n    return 'image'; // Default\r\n  };\r\n  const generatedMediaType: MediaType = getMediaType();\r\n\r\n  // Realtime subscription for media status updates\r\n  useEffect(() => {\r\n    if (!currentMediaId) return;\r\n\r\n    console.log(`[MediaGenerationForm] Setting up Realtime for media: ${currentMediaId}`);\r\n    \r\n    const channel = supabase\r\n      .channel(`generation-${currentMediaId}`)\r\n      .on(\r\n        'postgres_changes',\r\n        {\r\n          event: 'UPDATE',\r\n          schema: 'public',\r\n          table: 'generated_media',\r\n          filter: `id=eq.${currentMediaId}`\r\n        },\r\n        (payload) => {\r\n          console.log('[MediaGenerationForm] Realtime update:', payload);\r\n          const updated = payload.new as any;\r\n          \r\n          setPreviewStatus(updated.status);\r\n\r\n          if (updated.status === 'completed') {\r\n            setPreviewUrl(updated.media_url);\r\n            toast.success(`${generatedMediaType} generation complete!`);\r\n          } else if (updated.status === 'failed') {\r\n            const errorMsg = updated.metadata?.error || 'Generation failed';\r\n            toast.error(`Generation failed: ${errorMsg}`);\r\n          }\r\n        }\r\n      )\r\n      .subscribe((status) => {\r\n        if (status === 'SUBSCRIBED') {\r\n          console.log(`[MediaGenerationForm] Realtime SUBSCRIBED for ${currentMediaId}`);\r\n        } else if (status === 'CHANNEL_ERROR') {\r\n          console.error('[MediaGenerationForm] Realtime CHANNEL_ERROR');\r\n          toast.error('Connection error. Please refresh if status doesn\\'t update.');\r\n        }\r\n      });\r\n\r\n    // Cleanup on unmount or when currentMediaId changes\r\n    return () => {\r\n      console.log(`[MediaGenerationForm] Unsubscribing from Realtime for ${currentMediaId}`);\r\n      supabase.removeChannel(channel);\r\n    };\r\n  }, [currentMediaId, supabase, generatedMediaType]);\r\n\r\n  // --- Image Handling ---\r\n  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>, type: 'start' | 'end' | 'image1' | 'image2' | 'image3') => {\r\n    const file = event.target.files?.[0];\r\n    if (file) {\r\n      const reader = new FileReader();\r\n      reader.onloadend = () => {\r\n        const result = reader.result as string;\r\n        if (type === 'start') { setStartImageFile(file); setStartImageUrl(null); setStartImagePreview(result); }\r\n        else if (type === 'end') { setEndImageFile(file); setEndImageUrl(null); setEndImagePreview(result); }\r\n        else if (type === 'image1') { setImage1File(file); setImage1Url(null); setImage1Preview(result); }\r\n        else if (type === 'image2') { setImage2File(file); setImage2Url(null); setImage2Preview(result); }\r\n        else if (type === 'image3') { setImage3File(file); setImage3Url(null); setImage3Preview(result); }\r\n      };\r\n      reader.readAsDataURL(file);\r\n    } else {\r\n         if (type === 'start') { setStartImageFile(null); setStartImagePreview(null); }\r\n         else if (type === 'end') { setEndImageFile(null); setEndImagePreview(null); }\r\n         else if (type === 'image1') { setImage1File(null); setImage1Preview(null); }\r\n         else if (type === 'image2') { setImage2File(null); setImage2Preview(null); }\r\n         else if (type === 'image3') { setImage3File(null); setImage3Preview(null); }\r\n    }\r\n  };\r\n  const handleImageSelection = useCallback((url: string | null, type: 'start' | 'end' | 'image1' | 'image2' | 'image3') => {\r\n    if (type === 'start') { setStartImageUrl(url); setStartImageFile(null); setStartImagePreview(url); }\r\n    else if (type === 'end') { setEndImageUrl(url); setEndImageFile(null); setEndImagePreview(url); }\r\n    else if (type === 'image1') { setImage1Url(url); setImage1File(null); setImage1Preview(url); }\r\n    else if (type === 'image2') { setImage2Url(url); setImage2File(null); setImage2Preview(url); }\r\n    else if (type === 'image3') { setImage3Url(url); setImage3File(null); setImage3Preview(url); }\r\n  }, []);\r\n  const clearImage = (type: 'start' | 'end' | 'image1' | 'image2' | 'image3') => {\r\n    if (type === 'start') { setStartImageFile(null); setStartImageUrl(null); setStartImagePreview(null); if (startFileInputRef.current) startFileInputRef.current.value = \"\"; }\r\n    else if (type === 'end') { setEndImageFile(null); setEndImageUrl(null); setEndImagePreview(null); if (endFileInputRef.current) endFileInputRef.current.value = \"\"; }\r\n    else if (type === 'image1') { setImage1File(null); setImage1Url(null); setImage1Preview(null); if (image1FileInputRef.current) image1FileInputRef.current.value = \"\"; }\r\n    else if (type === 'image2') { setImage2File(null); setImage2Url(null); setImage2Preview(null); if (image2FileInputRef.current) image2FileInputRef.current.value = \"\"; }\r\n    else if (type === 'image3') { setImage3File(null); setImage3Url(null); setImage3Preview(null); if (image3FileInputRef.current) image3FileInputRef.current.value = \"\"; }\r\n  };\r\n\r\n  // Effect to reset preview if inputs change while generating\r\n  useEffect(() => {\r\n    const hasInputs = prompt || startImageFile || endImageFile || startImageUrl || endImageUrl ||\r\n                      image1File || image1Url || image2File || image2Url || image3File || image3Url ||\r\n                      positivePrompt || negativePrompt;\r\n    if (hasInputs && currentMediaId) {\r\n      console.log(\"MediaGenerationForm: Inputs changed during generation, resetting preview.\");\r\n      setCurrentMediaId(null);\r\n      setPreviewStatus('idle');\r\n      setPreviewUrl(null);\r\n    }\r\n  }, [prompt, startImageFile, endImageFile, startImageUrl, endImageUrl, image1File, image1Url, image2File, image2Url, image3File, image3Url, positivePrompt, negativePrompt, currentMediaId]);\r\n\r\n  // --- Submission Logic ---\r\n  async function handleSubmit(e: React.FormEvent) {\r\n    e.preventDefault();\r\n    if (!userId) { toast.error(\"User not identified. Please refresh.\"); return; }\r\n\r\n    // Validation based on generation mode\r\n    if (generationMode === 'firstLastFrameVideo') {\r\n      // Wan 2.2 - needs start/end images and prompt\r\n      if (!startImageFile && !startImageUrl) { toast.error(\"Please provide a start image.\"); return; }\r\n      if (!endImageFile && !endImageUrl) { toast.error(\"Please provide an end image.\"); return; }\r\n      if (!prompt.trim()) { toast.error(\"Please enter a prompt.\"); return; }\r\n    } else if (generationMode === 'video') {\r\n      // Qwen Edit - needs at least image1\r\n      if (!image1File && !image1Url) { toast.error(\"Please provide an image to edit.\"); return; }\r\n    } else if (generationMode === 'image') {\r\n      // Krea Flux - needs prompt only (width/height have defaults)\r\n      if (!prompt.trim()) { toast.error(\"Please enter a prompt.\"); return; }\r\n    }\r\n    \r\n    if (userCredits < creditCost) { toast.error(\"Not enough credits to generate.\"); return; }\r\n\r\n    setIsSubmitting(true);\r\n    setPreviewUrl(null);\r\n    setPreviewStatus('pending');\r\n\r\n    // Clear any existing generation tracking\r\n    setCurrentMediaId(null);\r\n\r\n    let finalStartImageUrl = startImageUrl;\r\n    let finalEndImageUrl = endImageUrl;\r\n\r\n    try {\r\n      // Image Compression & Direct Upload\r\n      if (generationMode === 'firstLastFrameVideo') {\r\n        const compressionOptions = { maxSizeMB: 0.95, maxWidthOrHeight: 1920, useWebWorker: true };\r\n\r\n        if (startImageFile) {\r\n          let compressedStartFile = startImageFile;\r\n          try {\r\n            const compressToastId = toast.loading(\"Compressing start image...\");\r\n            compressedStartFile = await imageCompression(startImageFile, compressionOptions);\r\n            toast.dismiss(compressToastId);\r\n          } catch (compressionError) { console.error(\"Start image compression failed:\", compressionError); toast.error(\"Failed to compress start image. Using original.\"); }\r\n          const uploadResult = await uploadDirectlyToSupabase(compressedStartFile, userId, 'start');\r\n          if (!uploadResult.success || !uploadResult.url) throw new Error(uploadResult.error || \"Failed to upload start image.\");\r\n          finalStartImageUrl = uploadResult.url;\r\n        }\r\n\r\n        if (endImageFile) {\r\n          let compressedEndFile = endImageFile;\r\n           try {\r\n            const compressToastId = toast.loading(\"Compressing end image...\");\r\n            compressedEndFile = await imageCompression(endImageFile, compressionOptions);\r\n            toast.dismiss(compressToastId);\r\n          } catch (compressionError) { console.error(\"End image compression failed:\", compressionError); toast.error(\"Failed to compress end image. Using original.\"); }\r\n          const uploadResult = await uploadDirectlyToSupabase(compressedEndFile, userId, 'end');\r\n           if (!uploadResult.success || !uploadResult.url) throw new Error(uploadResult.error || \"Failed to upload end image.\");\r\n          finalEndImageUrl = uploadResult.url;\r\n        }\r\n\r\n        if (!finalStartImageUrl || !finalEndImageUrl) throw new Error(\"Missing required image URLs after processing uploads.\");\r\n      }\r\n\r\n      // Handle Qwen Edit image uploads\r\n      let finalImage1Url = image1Url;\r\n      let finalImage2Url = image2Url;\r\n      let finalImage3Url = image3Url;\r\n      \r\n      if (generationMode === 'video') {\r\n        const compressionOptions = { maxSizeMB: 0.95, maxWidthOrHeight: 1920, useWebWorker: true };\r\n        \r\n        if (image1File) {\r\n          let compressedFile = image1File;\r\n          try {\r\n            const compressToastId = toast.loading(\"Compressing image 1...\");\r\n            compressedFile = await imageCompression(image1File, compressionOptions);\r\n            toast.dismiss(compressToastId);\r\n          } catch (error) {\r\n            console.error(\"Image 1 compression failed:\", error);\r\n          }\r\n          const uploadResult = await uploadDirectlyToSupabase(compressedFile, userId, 'image1');\r\n          if (!uploadResult.success || !uploadResult.url) throw new Error(\"Failed to upload image 1.\");\r\n          finalImage1Url = uploadResult.url;\r\n        }\r\n        \r\n        if (image2File) {\r\n          let compressedFile = image2File;\r\n          try {\r\n            const compressToastId = toast.loading(\"Compressing image 2...\");\r\n            compressedFile = await imageCompression(image2File, compressionOptions);\r\n            toast.dismiss(compressToastId);\r\n          } catch (error) {\r\n            console.error(\"Image 2 compression failed:\", error);\r\n          }\r\n          const uploadResult = await uploadDirectlyToSupabase(compressedFile, userId, 'image1');\r\n          if (!uploadResult.success || !uploadResult.url) throw new Error(\"Failed to upload image 2.\");\r\n          finalImage2Url = uploadResult.url;\r\n        }\r\n        \r\n        if (image3File) {\r\n          let compressedFile = image3File;\r\n          try {\r\n            const compressToastId = toast.loading(\"Compressing image 3...\");\r\n            compressedFile = await imageCompression(image3File, compressionOptions);\r\n            toast.dismiss(compressToastId);\r\n          } catch (error) {\r\n            console.error(\"Image 3 compression failed:\", error);\r\n          }\r\n          const uploadResult = await uploadDirectlyToSupabase(compressedFile, userId, 'image1');\r\n          if (!uploadResult.success || !uploadResult.url) throw new Error(\"Failed to upload image 3.\");\r\n          finalImage3Url = uploadResult.url;\r\n        }\r\n      }\r\n\r\n      // Prepare FormData with mode-specific data\r\n      const formData = new FormData();\r\n      formData.append('generationMode', generationMode);\r\n      formData.append('mediaType', generatedMediaType);\r\n      \r\n      if (generationMode === 'image') {\r\n        // Krea Flux\r\n        formData.append('prompt', prompt);\r\n        formData.append('width', width.toString());\r\n        formData.append('height', height.toString());\r\n      } else if (generationMode === 'video') {\r\n        // Qwen Edit\r\n        formData.append('image1Url', finalImage1Url!);\r\n        formData.append('positivePrompt', positivePrompt);\r\n        formData.append('negativePrompt', negativePrompt);\r\n        if (finalImage2Url) formData.append('image2Url', finalImage2Url);\r\n        if (finalImage3Url) formData.append('image3Url', finalImage3Url);\r\n      } else if (generationMode === 'firstLastFrameVideo') {\r\n        // Wan 2.2\r\n        formData.append('prompt', prompt);\r\n        formData.append('startImageUrl', finalStartImageUrl!);\r\n        formData.append('endImageUrl', finalEndImageUrl!);\r\n        formData.append('width', videoWidth.toString());\r\n        formData.append('height', videoHeight.toString());\r\n        formData.append('length', videoLength.toString());\r\n      }\r\n\r\n      // Call server action\r\n      const result = await generateMedia(formData);\r\n\r\n      if (!result.success || !result.mediaId) {\r\n        toast.error(result.error || 'Failed to start generation');\r\n        setPreviewStatus('failed');\r\n      } else {\r\n        toast.info(`Your ${generatedMediaType} generation has started!`);\r\n        setCurrentMediaId(result.mediaId); // This will trigger Realtime subscription\r\n        if (onGenerationStart) onGenerationStart(result.mediaId);\r\n      }\r\n    } catch (error: any) {\r\n      console.error(`Submission error:`, error);\r\n      toast.error(error.message || 'An unexpected error occurred during submission.');\r\n      setPreviewStatus('failed');\r\n      setCurrentMediaId(null);\r\n    } finally {\r\n      setIsSubmitting(false);\r\n    }\r\n  }\r\n\r\n  const isLoading = isSubmitting || (currentMediaId !== null && previewStatus === 'processing');\r\n  const isFirstLastMode = generationMode === 'firstLastFrameVideo';\r\n  const isQwenEdit = generationMode === 'video';\r\n  const isKreaFlux = generationMode === 'image';\r\n\r\n  // --- Render Image Input Helper ---\r\n  const renderImageInput = (type: 'start' | 'end' | 'image1' | 'image2' | 'image3', required: boolean = true) => {\r\n    let previewSrc, fileInputRef, selectedUrl, label;\r\n    \r\n    switch(type) {\r\n      case 'start':\r\n        previewSrc = startImagePreview;\r\n        fileInputRef = startFileInputRef;\r\n        selectedUrl = startImageUrl;\r\n        label = 'Start Image';\r\n        break;\r\n      case 'end':\r\n        previewSrc = endImagePreview;\r\n        fileInputRef = endFileInputRef;\r\n        selectedUrl = endImageUrl;\r\n        label = 'End Image';\r\n        break;\r\n      case 'image1':\r\n        previewSrc = image1Preview;\r\n        fileInputRef = image1FileInputRef;\r\n        selectedUrl = image1Url;\r\n        label = 'Primary Image';\r\n        break;\r\n      case 'image2':\r\n        previewSrc = image2Preview;\r\n        fileInputRef = image2FileInputRef;\r\n        selectedUrl = image2Url;\r\n        label = 'Reference Image 2 (Optional)';\r\n        break;\r\n      case 'image3':\r\n        previewSrc = image3Preview;\r\n        fileInputRef = image3FileInputRef;\r\n        selectedUrl = image3Url;\r\n        label = 'Reference Image 3 (Optional)';\r\n        break;\r\n    }\r\n    \r\n    return (\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor={`${type}-image-input`} className=\"text-base font-medium text-foreground/90\">{label}</Label>\r\n        <div className=\"flex items-center gap-2\">\r\n           <Input id={`${type}-image-input`} ref={fileInputRef} type=\"file\" accept=\"image/png, image/jpeg, image/webp, image/gif\" onChange={(e) => handleFileChange(e, type)} className=\"hidden\" disabled={isLoading}/>\r\n           <Button type=\"button\" variant=\"outline\" onClick={() => fileInputRef.current?.click()} disabled={isLoading} className=\"glass-input bg-white/5 border-white/15 hover:bg-white/10 text-foreground/80 flex-grow\"> <Upload className=\"mr-2 h-4 w-4\" /> Upload </Button>\r\n           <span className=\"text-xs text-muted-foreground mx-1\">OR</span>\r\n           <ImageSelectorPopover selectedUrl={selectedUrl} onImageSelect={(url) => handleImageSelection(url, type)} triggerText=\"Select Existing\" disabled={isLoading}/>\r\n        </div>\r\n        <div className=\"mt-2\" style={{ minHeight: '100px' }}>\r\n            <AnimatePresence>\r\n              {previewSrc && (\r\n                <motion.div key={`${type}-preview`} initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: '100px' }} exit={{ opacity: 0, height: 0 }} transition={{ duration: 0.3 }} className=\"relative border border-white/15 rounded-md overflow-hidden p-1 bg-black/10\" style={{ width: '100px' }}>\r\n                  <Image src={previewSrc} alt={`${type} image preview`} fill sizes=\"100px\" className=\"object-contain\" onError={(e) => console.error(`Error loading ${type} preview image:`, e)}/>\r\n                  <Button type=\"button\" variant=\"ghost\" size=\"icon\" className=\"absolute top-0 right-0 h-6 w-6 bg-black/50 text-white hover:bg-black/70 hover:text-destructive rounded-full m-1 z-10\" onClick={() => clearImage(type)} disabled={isLoading} title={`Remove ${type} image`}> <X className=\"h-4 w-4\" /> </Button>\r\n                </motion.div>\r\n              )}\r\n            </AnimatePresence>\r\n        </div>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // --- Main Return JSX ---\r\n  return (\r\n     <div className=\"grid md:grid-cols-2 gap-8 items-start\">\r\n      {/* Form Section */}\r\n      <motion.div initial={{ opacity: 0, x: -20 }} animate={{ opacity: 1, x: 0 }} transition={{ duration: 0.5 }} className=\"space-y-5\">\r\n        <form onSubmit={handleSubmit} className=\"space-y-5\">\r\n          \r\n          {/* Krea Flux Inputs (Image Generation) */}\r\n          {isKreaFlux && (\r\n            <>\r\n              <div>\r\n                <Label htmlFor=\"prompt\" className=\"block text-base font-medium mb-2 text-foreground/90\">Image Description</Label>\r\n                <Textarea id=\"prompt\" placeholder=\"Describe the image you want to create...\" value={prompt} onChange={(e) => setPrompt(e.target.value)} disabled={isLoading} rows={5} className=\"resize-none glass-input bg-white/5 border-white/15 focus:border-primary/60 focus:ring-primary/30 focus:ring-2 transition-all text-base p-3 rounded-lg\"/>\r\n              </div>\r\n              <div className=\"grid grid-cols-2 gap-4\">\r\n                <div>\r\n                  <Label htmlFor=\"width\" className=\"block text-sm font-medium mb-2 text-foreground/90\">Width</Label>\r\n                  <Input type=\"number\" id=\"width\" value={width} onChange={(e) => setWidth(parseInt(e.target.value) || 1024)} min={512} max={2048} step={64} disabled={isLoading} className=\"glass-input bg-white/5 border-white/15\"/>\r\n                </div>\r\n                <div>\r\n                  <Label htmlFor=\"height\" className=\"block text-sm font-medium mb-2 text-foreground/90\">Height</Label>\r\n                  <Input type=\"number\" id=\"height\" value={height} onChange={(e) => setHeight(parseInt(e.target.value) || 1024)} min={512} max={2048} step={64} disabled={isLoading} className=\"glass-input bg-white/5 border-white/15\"/>\r\n                </div>\r\n              </div>\r\n            </>\r\n          )}\r\n\r\n          {/* Qwen Edit Inputs (Image Editing) */}\r\n          {isQwenEdit && (\r\n            <>\r\n              {renderImageInput('image1', true)}\r\n              {renderImageInput('image2', false)}\r\n              {renderImageInput('image3', false)}\r\n              <div>\r\n                <Label htmlFor=\"positive\" className=\"block text-base font-medium mb-2 text-foreground/90\">Positive Prompt (Optional)</Label>\r\n                <Textarea id=\"positive\" placeholder=\"Describe what you want to see or enhance...\" value={positivePrompt} onChange={(e) => setPositivePrompt(e.target.value)} disabled={isLoading} rows={3} className=\"resize-none glass-input bg-white/5 border-white/15 focus:border-primary/60 focus:ring-primary/30 focus:ring-2 transition-all text-base p-3 rounded-lg\"/>\r\n              </div>\r\n              <div>\r\n                <Label htmlFor=\"negative\" className=\"block text-base font-medium mb-2 text-foreground/90\">Negative Prompt (Optional)</Label>\r\n                <Textarea id=\"negative\" placeholder=\"Describe what to avoid...\" value={negativePrompt} onChange={(e) => setNegativePrompt(e.target.value)} disabled={isLoading} rows={2} className=\"resize-none glass-input bg-white/5 border-white/15 focus:border-primary/60 focus:ring-primary/30 focus:ring-2 transition-all text-base p-3 rounded-lg\"/>\r\n              </div>\r\n            </>\r\n          )}\r\n\r\n          {/* Wan 2.2 Inputs (First/Last Frame Video) */}\r\n          {isFirstLastMode && (\r\n            <>\r\n              {renderImageInput('start', true)}\r\n              {renderImageInput('end', true)}\r\n              <div>\r\n                <Label htmlFor=\"prompt\" className=\"block text-base font-medium mb-2 text-foreground/90\">Positive Prompt</Label>\r\n                <Textarea id=\"prompt\" placeholder=\"e.g., 'car crashes through the wall and man comes into the frame screaming'\" value={prompt} onChange={(e) => setPrompt(e.target.value)} disabled={isLoading} rows={3} className=\"resize-none glass-input bg-white/5 border-white/15 focus:border-primary/60 focus:ring-primary/30 focus:ring-2 transition-all text-base p-3 rounded-lg\"/>\r\n              </div>\r\n              <div className=\"grid grid-cols-3 gap-4\">\r\n                <div>\r\n                  <Label htmlFor=\"videoWidth\" className=\"block text-sm font-medium mb-2 text-foreground/90\">Width</Label>\r\n                  <Input type=\"number\" id=\"videoWidth\" value={videoWidth} onChange={(e) => setVideoWidth(parseInt(e.target.value) || 512)} min={256} max={1024} step={64} disabled={isLoading} className=\"glass-input bg-white/5 border-white/15\"/>\r\n                </div>\r\n                <div>\r\n                  <Label htmlFor=\"videoHeight\" className=\"block text-sm font-medium mb-2 text-foreground/90\">Height</Label>\r\n                  <Input type=\"number\" id=\"videoHeight\" value={videoHeight} onChange={(e) => setVideoHeight(parseInt(e.target.value) || 512)} min={256} max={1024} step={64} disabled={isLoading} className=\"glass-input bg-white/5 border-white/15\"/>\r\n                </div>\r\n                <div>\r\n                  <Label htmlFor=\"videoLength\" className=\"block text-sm font-medium mb-2 text-foreground/90\">Length (frames)</Label>\r\n                  <Input type=\"number\" id=\"videoLength\" value={videoLength} onChange={(e) => setVideoLength(parseInt(e.target.value) || 81)} min={25} max={200} step={1} disabled={isLoading} className=\"glass-input bg-white/5 border-white/15\"/>\r\n                </div>\r\n              </div>\r\n            </>\r\n          )}\r\n\r\n          <Button\r\n            type=\"submit\"\r\n            disabled={\r\n              isLoading ||\r\n              !userId ||\r\n              userCredits < creditCost ||\r\n              (isKreaFlux && !prompt.trim()) ||\r\n              (isQwenEdit && !image1File && !image1Url) ||\r\n              (isFirstLastMode && ((!startImageFile && !startImageUrl) || (!endImageFile && !endImageUrl) || !prompt.trim()))\r\n            }\r\n            className=\"w-full glass-button bg-gradient-to-r from-primary to-secondary text-white hover:opacity-95 hover:shadow-lg transition-all duration-300 shadow-md text-lg py-3 font-semibold\"\r\n          >\r\n            {isLoading ? ( <><Loader2 className=\"mr-2 h-5 w-5 animate-spin\" /> {isSubmitting ? 'Starting...' : 'Generating...'}</> ) : ( <><Sparkles className=\"mr-2 h-5 w-5\" /> Generate ({creditCost} credits)</> )}\r\n          </Button>\r\n        </form>\r\n        <div className=\"text-base text-muted-foreground border-t border-white/15 pt-4 space-y-1 bg-white/5 p-4 rounded-lg shadow-inner\">\r\n          <p><span className=\"font-semibold text-foreground/95\">Cost:</span> <span className=\"text-primary font-medium\">{creditCost}</span> credits</p>\r\n          <p><span className=\"font-semibold text-foreground/95\">Available:</span> <span className=\"text-primary font-medium\">{userCredits.toLocaleString()}</span> credits</p>\r\n          {userCredits < creditCost && !isLoading && ( <p className=\"text-destructive text-sm flex items-center gap-1 pt-1\"><AlertCircle className=\"w-4 h-4\"/> Not enough credits.</p> )}\r\n        </div>\r\n      </motion.div>\r\n\r\n      {/* Preview Section */}\r\n      <motion.div initial={{ opacity: 0, x: 20 }} animate={{ opacity: 1, x: 0 }} transition={{ duration: 0.5, delay: 0.1 }} className=\"flex flex-col\">\r\n        <label className=\"block text-base font-medium mb-2 text-foreground/90\"> Result preview </label>\r\n        <div className=\"relative glass-card bg-black/10 border border-white/15 rounded-lg aspect-video md:aspect-square flex items-center justify-center overflow-hidden shadow-inner p-2\">\r\n          <AnimatePresence mode=\"wait\">\r\n            {/* Loading State */}\r\n            {isLoading && (previewStatus === 'pending' || previewStatus === 'processing') && (\r\n              <motion.div key=\"loading\" initial={{ opacity: 0, scale: 0.9 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.9 }} transition={{ duration: 0.3 }} className=\"text-center p-4 flex flex-col items-center justify-center absolute inset-0 bg-black/40 backdrop-blur-md rounded-lg\"> <Loader2 className=\"h-12 w-12 animate-spin text-primary mb-4\" /> <p className=\"text-base font-medium text-foreground\">Generating your {generatedMediaType}...</p> <p className=\"text-sm text-muted-foreground mt-1\">Checking status...</p> </motion.div>\r\n            )}\r\n            {/* Completed State */}\r\n            {previewStatus === 'completed' && previewUrl && (\r\n              <motion.div key=\"completed\" initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.5 }} className=\"relative w-full h-full\">\r\n                {generatedMediaType === 'video' ? ( <video src={previewUrl} controls className=\"w-full h-full object-contain rounded-md\" preload=\"metadata\" /> ) : ( <Image src={previewUrl} alt={prompt || \"Generated Media\"} fill className=\"object-contain rounded-md\" unoptimized={true} /> )}\r\n              </motion.div>\r\n            )}\r\n            {/* Failed State */}\r\n            {previewStatus === 'failed' && !isLoading && ( // Only show failed if not actively loading/polling\r\n              <motion.div key=\"failed\" initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: 10 }} transition={{ duration: 0.3 }} className=\"text-center p-4 flex flex-col items-center justify-center absolute inset-0 bg-destructive/20 backdrop-blur-sm rounded-lg\"> <AlertCircle className=\"h-12 w-12 text-destructive-foreground mb-4\" /> <p className=\"text-base font-medium text-destructive-foreground\">Generation failed.</p> <p className=\"text-sm text-destructive-foreground/80 mt-1\">Check library or try again.</p> </motion.div>\r\n            )}\r\n            {/* Idle State */}\r\n            {previewStatus === 'idle' && !isLoading && (\r\n              <motion.div key=\"idle\" initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.3 }} className=\"text-center p-4 flex flex-col items-center justify-center text-muted-foreground\"> <div className=\"rounded-full bg-primary/10 p-5 w-fit mx-auto mb-5 border border-primary/20 shadow-sm\"> {generatedMediaType === 'image' ? <LucideImage className=\"h-10 w-10 text-primary/80\" /> : <Film className=\"h-10 w-10 text-primary/80\" />} </div> <p className=\"text-base\"> Your {generatedMediaType} preview will appear here </p> </motion.div>\r\n            )}\r\n          </AnimatePresence>\r\n        </div>\r\n      </motion.div>\r\n    </div>\r\n  );\r\n}\r\n"],"names":[],"mappings":"AAAA,qDAAqD;;;;;AAGrD;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sSAAqC,uBAAuB;AAjB5D;;;;;;;;;;;;;;;;AA6BA,6CAA6C;AAC7C,eAAe,yBACX,IAAU,EACV,MAAc,EACd,IAAgC;IAEhC,IAAI,CAAC,QAAQ,CAAC,QAAQ;QAClB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAiC;IACrE;IAEA,MAAM,WAAW,CAAA,GAAA,4IAAA,CAAA,eAAY,AAAD,KAAK,6BAA6B;IAE9D,IAAI;QACA,MAAM,gBAAgB,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,IAAI,iBAAiB;QACnE,sCAAsC;QACtC,MAAM,WAAW,GAAG,KAAK,CAAC,EAAE,CAAA,GAAA,0KAAA,CAAA,KAAM,AAAD,IAAI,CAAC,EAAE,eAAe;QACvD,MAAM,cAAc,GAAG,OAAO,QAAQ,EAAE,UAAU,EAAE,uCAAuC;QAE3F,QAAQ,GAAG,CAAC,CAAC,mCAAmC,EAAE,aAAa;QAC/D,MAAM,gBAAgB,wIAAA,CAAA,QAAK,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,KAAK,SAAS,CAAC,EAAE;YAAE,UAAU;QAAM,IAAI,kCAAkC;QAEvH,MAAM,EAAE,IAAI,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SAAS,OAAO,CACtD,IAAI,CAAC,mBAAmB,mBAAmB;SAC3C,MAAM,CAAC,aAAa,MAAM;YACvB,cAAc;YACd,QAAQ;YACR,aAAa,KAAK,IAAI;QAC1B;QAEJ,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC,gBAAgB,iDAAiD;QAE/E,IAAI,aAAa;YACb,QAAQ,KAAK,CAAC,CAAC,qBAAqB,EAAE,KAAK,EAAE,CAAC,EAAE;YAChD,MAAM,IAAI,MAAM,CAAC,sBAAsB,EAAE,YAAY,OAAO,EAAE;QAClE;QAEA,iBAAiB;QACjB,MAAM,EAAE,MAAM,aAAa,EAAE,GAAG,SAAS,OAAO,CAC3C,IAAI,CAAC,mBACL,YAAY,CAAC;QAElB,IAAI,CAAC,eAAe,WAAW;YAC3B,MAAM,IAAI,MAAM;QACpB;QAEA,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,KAAK,GAAG,EAAE,cAAc,SAAS,EAAE;QACzE,8GAA8G;QAE9G,OAAO;YAAE,SAAS;YAAM,KAAK,cAAc,SAAS;QAAC;IAEzD,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,CAAC,mCAAmC,EAAE,KAAK,EAAE,CAAC,EAAE;QAC9D,8DAA8D;QAC9D,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC,CAAC,iBAAiB,EAAE,KAAK,OAAO,CAAC;QAC7C,OAAO;YAAE,SAAS;YAAO,OAAO,MAAM,OAAO;QAAC;IAClD;AACJ;AAGO,SAAS,oBAAoB,EAClC,cAAc,EACd,UAAU,EACV,WAAW,EACX,iBAAiB,EACQ;IACzB,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IACrC,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAe;IAClE,MAAM,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAe;IAC9D,MAAM,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAClE,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAC9D,MAAM,CAAC,mBAAmB,qBAAqB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAC1E,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAEtE,4BAA4B;IAC5B,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAe;IAC1D,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAC1D,MAAM,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAClE,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAe;IAC1D,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAC1D,MAAM,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAClE,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAe;IAC1D,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAC1D,MAAM,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAClE,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IACrD,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAErD,4BAA4B;IAC5B,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IACnC,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAErC,0BAA0B;IAC1B,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAC7C,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAC/C,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAE/C,MAAM,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IACjD,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IACpE,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAC5D,MAAM,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAwB;IACzE,MAAM,oBAAoB,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAoB;IACnD,MAAM,kBAAkB,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAoB;IACjD,MAAM,qBAAqB,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAoB;IACpD,MAAM,qBAAqB,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAoB;IACpD,MAAM,qBAAqB,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAoB;IACpD,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAEpD,MAAM,WAAW,CAAA,GAAA,4IAAA,CAAA,eAAY,AAAD,KAAK,6CAA6C;IAE9E,uBAAuB;IACvB,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,MAAM,UAAU;YACd,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;YACtD,UAAU,MAAM,MAAM;YACtB,IAAI,CAAC,MAAM,QAAQ,IAAI,CAAC;QAC1B;QACA;IACF,GAAG;QAAC;KAAS;IAEb,sDAAsD;IACtD,MAAM,eAAe;QACnB,IAAI,mBAAmB,SAAS,OAAO,SAAS,oBAAoB;QACpE,IAAI,mBAAmB,SAAS,OAAO,SAAU,yDAAyD;QAC1G,IAAI,mBAAmB,uBAAuB,OAAO,SAAS,kBAAkB;QAChF,OAAO,SAAS,UAAU;IAC5B;IACA,MAAM,qBAAgC;IAEtC,iDAAiD;IACjD,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,IAAI,CAAC,gBAAgB;QAErB,QAAQ,GAAG,CAAC,CAAC,qDAAqD,EAAE,gBAAgB;QAEpF,MAAM,UAAU,SACb,OAAO,CAAC,CAAC,WAAW,EAAE,gBAAgB,EACtC,EAAE,CACD,oBACA;YACE,OAAO;YACP,QAAQ;YACR,OAAO;YACP,QAAQ,CAAC,MAAM,EAAE,gBAAgB;QACnC,GACA,CAAC;YACC,QAAQ,GAAG,CAAC,0CAA0C;YACtD,MAAM,UAAU,QAAQ,GAAG;YAE3B,iBAAiB,QAAQ,MAAM;YAE/B,IAAI,QAAQ,MAAM,KAAK,aAAa;gBAClC,cAAc,QAAQ,SAAS;gBAC/B,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC,GAAG,mBAAmB,qBAAqB,CAAC;YAC5D,OAAO,IAAI,QAAQ,MAAM,KAAK,UAAU;gBACtC,MAAM,WAAW,QAAQ,QAAQ,EAAE,SAAS;gBAC5C,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC,CAAC,mBAAmB,EAAE,UAAU;YAC9C;QACF,GAED,SAAS,CAAC,CAAC;YACV,IAAI,WAAW,cAAc;gBAC3B,QAAQ,GAAG,CAAC,CAAC,8CAA8C,EAAE,gBAAgB;YAC/E,OAAO,IAAI,WAAW,iBAAiB;gBACrC,QAAQ,KAAK,CAAC;gBACd,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC;YACd;QACF;QAEF,oDAAoD;QACpD,OAAO;YACL,QAAQ,GAAG,CAAC,CAAC,sDAAsD,EAAE,gBAAgB;YACrF,SAAS,aAAa,CAAC;QACzB;IACF,GAAG;QAAC;QAAgB;QAAU;KAAmB;IAEjD,yBAAyB;IACzB,MAAM,mBAAmB,CAAC,OAA4C;QACpE,MAAM,OAAO,MAAM,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE;QACpC,IAAI,MAAM;YACR,MAAM,SAAS,IAAI;YACnB,OAAO,SAAS,GAAG;gBACjB,MAAM,SAAS,OAAO,MAAM;gBAC5B,IAAI,SAAS,SAAS;oBAAE,kBAAkB;oBAAO,iBAAiB;oBAAO,qBAAqB;gBAAS,OAClG,IAAI,SAAS,OAAO;oBAAE,gBAAgB;oBAAO,eAAe;oBAAO,mBAAmB;gBAAS,OAC/F,IAAI,SAAS,UAAU;oBAAE,cAAc;oBAAO,aAAa;oBAAO,iBAAiB;gBAAS,OAC5F,IAAI,SAAS,UAAU;oBAAE,cAAc;oBAAO,aAAa;oBAAO,iBAAiB;gBAAS,OAC5F,IAAI,SAAS,UAAU;oBAAE,cAAc;oBAAO,aAAa;oBAAO,iBAAiB;gBAAS;YACnG;YACA,OAAO,aAAa,CAAC;QACvB,OAAO;YACF,IAAI,SAAS,SAAS;gBAAE,kBAAkB;gBAAO,qBAAqB;YAAO,OACxE,IAAI,SAAS,OAAO;gBAAE,gBAAgB;gBAAO,mBAAmB;YAAO,OACvE,IAAI,SAAS,UAAU;gBAAE,cAAc;gBAAO,iBAAiB;YAAO,OACtE,IAAI,SAAS,UAAU;gBAAE,cAAc;gBAAO,iBAAiB;YAAO,OACtE,IAAI,SAAS,UAAU;gBAAE,cAAc;gBAAO,iBAAiB;YAAO;QAChF;IACF;IACA,MAAM,uBAAuB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE,CAAC,KAAoB;QAC5D,IAAI,SAAS,SAAS;YAAE,iBAAiB;YAAM,kBAAkB;YAAO,qBAAqB;QAAM,OAC9F,IAAI,SAAS,OAAO;YAAE,eAAe;YAAM,gBAAgB;YAAO,mBAAmB;QAAM,OAC3F,IAAI,SAAS,UAAU;YAAE,aAAa;YAAM,cAAc;YAAO,iBAAiB;QAAM,OACxF,IAAI,SAAS,UAAU;YAAE,aAAa;YAAM,cAAc;YAAO,iBAAiB;QAAM,OACxF,IAAI,SAAS,UAAU;YAAE,aAAa;YAAM,cAAc;YAAO,iBAAiB;QAAM;IAC/F,GAAG,EAAE;IACL,MAAM,aAAa,CAAC;QAClB,IAAI,SAAS,SAAS;YAAE,kBAAkB;YAAO,iBAAiB;YAAO,qBAAqB;YAAO,IAAI,kBAAkB,OAAO,EAAE,kBAAkB,OAAO,CAAC,KAAK,GAAG;QAAI,OACrK,IAAI,SAAS,OAAO;YAAE,gBAAgB;YAAO,eAAe;YAAO,mBAAmB;YAAO,IAAI,gBAAgB,OAAO,EAAE,gBAAgB,OAAO,CAAC,KAAK,GAAG;QAAI,OAC9J,IAAI,SAAS,UAAU;YAAE,cAAc;YAAO,aAAa;YAAO,iBAAiB;YAAO,IAAI,mBAAmB,OAAO,EAAE,mBAAmB,OAAO,CAAC,KAAK,GAAG;QAAI,OACjK,IAAI,SAAS,UAAU;YAAE,cAAc;YAAO,aAAa;YAAO,iBAAiB;YAAO,IAAI,mBAAmB,OAAO,EAAE,mBAAmB,OAAO,CAAC,KAAK,GAAG;QAAI,OACjK,IAAI,SAAS,UAAU;YAAE,cAAc;YAAO,aAAa;YAAO,iBAAiB;YAAO,IAAI,mBAAmB,OAAO,EAAE,mBAAmB,OAAO,CAAC,KAAK,GAAG;QAAI;IACxK;IAEA,4DAA4D;IAC5D,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,MAAM,YAAY,UAAU,kBAAkB,gBAAgB,iBAAiB,eAC7D,cAAc,aAAa,cAAc,aAAa,cAAc,aACpE,kBAAkB;QACpC,IAAI,aAAa,gBAAgB;YAC/B,QAAQ,GAAG,CAAC;YACZ,kBAAkB;YAClB,iBAAiB;YACjB,cAAc;QAChB;IACF,GAAG;QAAC;QAAQ;QAAgB;QAAc;QAAe;QAAa;QAAY;QAAW;QAAY;QAAW;QAAY;QAAW;QAAgB;QAAgB;KAAe;IAE1L,2BAA2B;IAC3B,eAAe,aAAa,CAAkB;QAC5C,EAAE,cAAc;QAChB,IAAI,CAAC,QAAQ;YAAE,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC;YAAyC;QAAQ;QAE5E,sCAAsC;QACtC,IAAI,mBAAmB,uBAAuB;YAC5C,8CAA8C;YAC9C,IAAI,CAAC,kBAAkB,CAAC,eAAe;gBAAE,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC;gBAAkC;YAAQ;YAC/F,IAAI,CAAC,gBAAgB,CAAC,aAAa;gBAAE,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC;gBAAiC;YAAQ;YAC1F,IAAI,CAAC,OAAO,IAAI,IAAI;gBAAE,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC;gBAA2B;YAAQ;QACvE,OAAO,IAAI,mBAAmB,SAAS;YACrC,oCAAoC;YACpC,IAAI,CAAC,cAAc,CAAC,WAAW;gBAAE,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC;gBAAqC;YAAQ;QAC5F,OAAO,IAAI,mBAAmB,SAAS;YACrC,6DAA6D;YAC7D,IAAI,CAAC,OAAO,IAAI,IAAI;gBAAE,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC;gBAA2B;YAAQ;QACvE;QAEA,IAAI,cAAc,YAAY;YAAE,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC;YAAoC;QAAQ;QAExF,gBAAgB;QAChB,cAAc;QACd,iBAAiB;QAEjB,yCAAyC;QACzC,kBAAkB;QAElB,IAAI,qBAAqB;QACzB,IAAI,mBAAmB;QAEvB,IAAI;YACF,oCAAoC;YACpC,IAAI,mBAAmB,uBAAuB;gBAC5C,MAAM,qBAAqB;oBAAE,WAAW;oBAAM,kBAAkB;oBAAM,cAAc;gBAAK;gBAEzF,IAAI,gBAAgB;oBAClB,IAAI,sBAAsB;oBAC1B,IAAI;wBACF,MAAM,kBAAkB,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC;wBACtC,sBAAsB,MAAM,CAAA,GAAA,2LAAA,CAAA,UAAgB,AAAD,EAAE,gBAAgB;wBAC7D,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC;oBAChB,EAAE,OAAO,kBAAkB;wBAAE,QAAQ,KAAK,CAAC,mCAAmC;wBAAmB,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC;oBAAoD;oBACjK,MAAM,eAAe,MAAM,yBAAyB,qBAAqB,QAAQ;oBACjF,IAAI,CAAC,aAAa,OAAO,IAAI,CAAC,aAAa,GAAG,EAAE,MAAM,IAAI,MAAM,aAAa,KAAK,IAAI;oBACtF,qBAAqB,aAAa,GAAG;gBACvC;gBAEA,IAAI,cAAc;oBAChB,IAAI,oBAAoB;oBACvB,IAAI;wBACH,MAAM,kBAAkB,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC;wBACtC,oBAAoB,MAAM,CAAA,GAAA,2LAAA,CAAA,UAAgB,AAAD,EAAE,cAAc;wBACzD,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC;oBAChB,EAAE,OAAO,kBAAkB;wBAAE,QAAQ,KAAK,CAAC,iCAAiC;wBAAmB,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC;oBAAkD;oBAC7J,MAAM,eAAe,MAAM,yBAAyB,mBAAmB,QAAQ;oBAC9E,IAAI,CAAC,aAAa,OAAO,IAAI,CAAC,aAAa,GAAG,EAAE,MAAM,IAAI,MAAM,aAAa,KAAK,IAAI;oBACvF,mBAAmB,aAAa,GAAG;gBACrC;gBAEA,IAAI,CAAC,sBAAsB,CAAC,kBAAkB,MAAM,IAAI,MAAM;YAChE;YAEA,iCAAiC;YACjC,IAAI,iBAAiB;YACrB,IAAI,iBAAiB;YACrB,IAAI,iBAAiB;YAErB,IAAI,mBAAmB,SAAS;gBAC9B,MAAM,qBAAqB;oBAAE,WAAW;oBAAM,kBAAkB;oBAAM,cAAc;gBAAK;gBAEzF,IAAI,YAAY;oBACd,IAAI,iBAAiB;oBACrB,IAAI;wBACF,MAAM,kBAAkB,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC;wBACtC,iBAAiB,MAAM,CAAA,GAAA,2LAAA,CAAA,UAAgB,AAAD,EAAE,YAAY;wBACpD,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC;oBAChB,EAAE,OAAO,OAAO;wBACd,QAAQ,KAAK,CAAC,+BAA+B;oBAC/C;oBACA,MAAM,eAAe,MAAM,yBAAyB,gBAAgB,QAAQ;oBAC5E,IAAI,CAAC,aAAa,OAAO,IAAI,CAAC,aAAa,GAAG,EAAE,MAAM,IAAI,MAAM;oBAChE,iBAAiB,aAAa,GAAG;gBACnC;gBAEA,IAAI,YAAY;oBACd,IAAI,iBAAiB;oBACrB,IAAI;wBACF,MAAM,kBAAkB,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC;wBACtC,iBAAiB,MAAM,CAAA,GAAA,2LAAA,CAAA,UAAgB,AAAD,EAAE,YAAY;wBACpD,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC;oBAChB,EAAE,OAAO,OAAO;wBACd,QAAQ,KAAK,CAAC,+BAA+B;oBAC/C;oBACA,MAAM,eAAe,MAAM,yBAAyB,gBAAgB,QAAQ;oBAC5E,IAAI,CAAC,aAAa,OAAO,IAAI,CAAC,aAAa,GAAG,EAAE,MAAM,IAAI,MAAM;oBAChE,iBAAiB,aAAa,GAAG;gBACnC;gBAEA,IAAI,YAAY;oBACd,IAAI,iBAAiB;oBACrB,IAAI;wBACF,MAAM,kBAAkB,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC;wBACtC,iBAAiB,MAAM,CAAA,GAAA,2LAAA,CAAA,UAAgB,AAAD,EAAE,YAAY;wBACpD,wIAAA,CAAA,QAAK,CAAC,OAAO,CAAC;oBAChB,EAAE,OAAO,OAAO;wBACd,QAAQ,KAAK,CAAC,+BAA+B;oBAC/C;oBACA,MAAM,eAAe,MAAM,yBAAyB,gBAAgB,QAAQ;oBAC5E,IAAI,CAAC,aAAa,OAAO,IAAI,CAAC,aAAa,GAAG,EAAE,MAAM,IAAI,MAAM;oBAChE,iBAAiB,aAAa,GAAG;gBACnC;YACF;YAEA,2CAA2C;YAC3C,MAAM,WAAW,IAAI;YACrB,SAAS,MAAM,CAAC,kBAAkB;YAClC,SAAS,MAAM,CAAC,aAAa;YAE7B,IAAI,mBAAmB,SAAS;gBAC9B,YAAY;gBACZ,SAAS,MAAM,CAAC,UAAU;gBAC1B,SAAS,MAAM,CAAC,SAAS,MAAM,QAAQ;gBACvC,SAAS,MAAM,CAAC,UAAU,OAAO,QAAQ;YAC3C,OAAO,IAAI,mBAAmB,SAAS;gBACrC,YAAY;gBACZ,SAAS,MAAM,CAAC,aAAa;gBAC7B,SAAS,MAAM,CAAC,kBAAkB;gBAClC,SAAS,MAAM,CAAC,kBAAkB;gBAClC,IAAI,gBAAgB,SAAS,MAAM,CAAC,aAAa;gBACjD,IAAI,gBAAgB,SAAS,MAAM,CAAC,aAAa;YACnD,OAAO,IAAI,mBAAmB,uBAAuB;gBACnD,UAAU;gBACV,SAAS,MAAM,CAAC,UAAU;gBAC1B,SAAS,MAAM,CAAC,iBAAiB;gBACjC,SAAS,MAAM,CAAC,eAAe;gBAC/B,SAAS,MAAM,CAAC,SAAS,WAAW,QAAQ;gBAC5C,SAAS,MAAM,CAAC,UAAU,YAAY,QAAQ;gBAC9C,SAAS,MAAM,CAAC,UAAU,YAAY,QAAQ;YAChD;YAEA,qBAAqB;YACrB,MAAM,SAAS,MAAM,CAAA,GAAA,4KAAA,CAAA,gBAAa,AAAD,EAAE;YAEnC,IAAI,CAAC,OAAO,OAAO,IAAI,CAAC,OAAO,OAAO,EAAE;gBACtC,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC,OAAO,KAAK,IAAI;gBAC5B,iBAAiB;YACnB,OAAO;gBACL,wIAAA,CAAA,QAAK,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,mBAAmB,wBAAwB,CAAC;gBAC/D,kBAAkB,OAAO,OAAO,GAAG,0CAA0C;gBAC7E,IAAI,mBAAmB,kBAAkB,OAAO,OAAO;YACzD;QACF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,CAAC,iBAAiB,CAAC,EAAE;YACnC,wIAAA,CAAA,QAAK,CAAC,KAAK,CAAC,MAAM,OAAO,IAAI;YAC7B,iBAAiB;YACjB,kBAAkB;QACpB,SAAU;YACR,gBAAgB;QAClB;IACF;IAEA,MAAM,YAAY,gBAAiB,mBAAmB,QAAQ,kBAAkB;IAChF,MAAM,kBAAkB,mBAAmB;IAC3C,MAAM,aAAa,mBAAmB;IACtC,MAAM,aAAa,mBAAmB;IAEtC,oCAAoC;IACpC,MAAM,mBAAmB,CAAC,MAAwD,WAAoB,IAAI;QACxG,IAAI,YAAY,cAAc,aAAa;QAE3C,OAAO;YACL,KAAK;gBACH,aAAa;gBACb,eAAe;gBACf,cAAc;gBACd,QAAQ;gBACR;YACF,KAAK;gBACH,aAAa;gBACb,eAAe;gBACf,cAAc;gBACd,QAAQ;gBACR;YACF,KAAK;gBACH,aAAa;gBACb,eAAe;gBACf,cAAc;gBACd,QAAQ;gBACR;YACF,KAAK;gBACH,aAAa;gBACb,eAAe;gBACf,cAAc;gBACd,QAAQ;gBACR;YACF,KAAK;gBACH,aAAa;gBACb,eAAe;gBACf,cAAc;gBACd,QAAQ;gBACR;QACJ;QAEA,qBACE,8OAAC;YAAI,WAAU;;8BACb,8OAAC,mJAAA,CAAA,QAAK;oBAAC,SAAS,GAAG,KAAK,YAAY,CAAC;oBAAE,WAAU;8BAA4C;;;;;;8BAC7F,8OAAC;oBAAI,WAAU;;sCACZ,8OAAC,mJAAA,CAAA,QAAK;4BAAC,IAAI,GAAG,KAAK,YAAY,CAAC;4BAAE,KAAK;4BAAc,MAAK;4BAAO,QAAO;4BAA+C,UAAU,CAAC,IAAM,iBAAiB,GAAG;4BAAO,WAAU;4BAAS,UAAU;;;;;;sCAChM,8OAAC,oJAAA,CAAA,SAAM;4BAAC,MAAK;4BAAS,SAAQ;4BAAU,SAAS,IAAM,aAAa,OAAO,EAAE;4BAAS,UAAU;4BAAW,WAAU;;gCAAwF;8CAAC,8OAAC,sMAAA,CAAA,SAAM;oCAAC,WAAU;;;;;;gCAAiB;;;;;;;sCACjP,8OAAC;4BAAK,WAAU;sCAAqC;;;;;;sCACrD,8OAAC,8KAAA,CAAA,uBAAoB;4BAAC,aAAa;4BAAa,eAAe,CAAC,MAAQ,qBAAqB,KAAK;4BAAO,aAAY;4BAAkB,UAAU;;;;;;;;;;;;8BAEpJ,8OAAC;oBAAI,WAAU;oBAAO,OAAO;wBAAE,WAAW;oBAAQ;8BAC9C,cAAA,8OAAC,yLAAA,CAAA,kBAAe;kCACb,4BACC,8OAAC,0LAAA,CAAA,SAAM,CAAC,GAAG;4BAAyB,SAAS;gCAAE,SAAS;gCAAG,QAAQ;4BAAE;4BAAG,SAAS;gCAAE,SAAS;gCAAG,QAAQ;4BAAQ;4BAAG,MAAM;gCAAE,SAAS;gCAAG,QAAQ;4BAAE;4BAAG,YAAY;gCAAE,UAAU;4BAAI;4BAAG,WAAU;4BAA6E,OAAO;gCAAE,OAAO;4BAAQ;;8CAC/R,8OAAC,6HAAA,CAAA,UAAK;oCAAC,KAAK;oCAAY,KAAK,GAAG,KAAK,cAAc,CAAC;oCAAE,IAAI;oCAAC,OAAM;oCAAQ,WAAU;oCAAiB,SAAS,CAAC,IAAM,QAAQ,KAAK,CAAC,CAAC,cAAc,EAAE,KAAK,eAAe,CAAC,EAAE;;;;;;8CAC1K,8OAAC,oJAAA,CAAA,SAAM;oCAAC,MAAK;oCAAS,SAAQ;oCAAQ,MAAK;oCAAO,WAAU;oCAAuH,SAAS,IAAM,WAAW;oCAAO,UAAU;oCAAW,OAAO,CAAC,OAAO,EAAE,KAAK,MAAM,CAAC;;wCAAE;sDAAC,8OAAC,4LAAA,CAAA,IAAC;4CAAC,WAAU;;;;;;wCAAY;;;;;;;;2BAFnR,GAAG,KAAK,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;IAShD;IAEA,0BAA0B;IAC1B,qBACG,8OAAC;QAAI,WAAU;;0BAEd,8OAAC,0LAAA,CAAA,SAAM,CAAC,GAAG;gBAAC,SAAS;oBAAE,SAAS;oBAAG,GAAG,CAAC;gBAAG;gBAAG,SAAS;oBAAE,SAAS;oBAAG,GAAG;gBAAE;gBAAG,YAAY;oBAAE,UAAU;gBAAI;gBAAG,WAAU;;kCACnH,8OAAC;wBAAK,UAAU;wBAAc,WAAU;;4BAGrC,4BACC;;kDACE,8OAAC;;0DACC,8OAAC,mJAAA,CAAA,QAAK;gDAAC,SAAQ;gDAAS,WAAU;0DAAsD;;;;;;0DACxF,8OAAC,sJAAA,CAAA,WAAQ;gDAAC,IAAG;gDAAS,aAAY;gDAA2C,OAAO;gDAAQ,UAAU,CAAC,IAAM,UAAU,EAAE,MAAM,CAAC,KAAK;gDAAG,UAAU;gDAAW,MAAM;gDAAG,WAAU;;;;;;;;;;;;kDAElL,8OAAC;wCAAI,WAAU;;0DACb,8OAAC;;kEACC,8OAAC,mJAAA,CAAA,QAAK;wDAAC,SAAQ;wDAAQ,WAAU;kEAAoD;;;;;;kEACrF,8OAAC,mJAAA,CAAA,QAAK;wDAAC,MAAK;wDAAS,IAAG;wDAAQ,OAAO;wDAAO,UAAU,CAAC,IAAM,SAAS,SAAS,EAAE,MAAM,CAAC,KAAK,KAAK;wDAAO,KAAK;wDAAK,KAAK;wDAAM,MAAM;wDAAI,UAAU;wDAAW,WAAU;;;;;;;;;;;;0DAE3K,8OAAC;;kEACC,8OAAC,mJAAA,CAAA,QAAK;wDAAC,SAAQ;wDAAS,WAAU;kEAAoD;;;;;;kEACtF,8OAAC,mJAAA,CAAA,QAAK;wDAAC,MAAK;wDAAS,IAAG;wDAAS,OAAO;wDAAQ,UAAU,CAAC,IAAM,UAAU,SAAS,EAAE,MAAM,CAAC,KAAK,KAAK;wDAAO,KAAK;wDAAK,KAAK;wDAAM,MAAM;wDAAI,UAAU;wDAAW,WAAU;;;;;;;;;;;;;;;;;;;;4BAOnL,4BACC;;oCACG,iBAAiB,UAAU;oCAC3B,iBAAiB,UAAU;oCAC3B,iBAAiB,UAAU;kDAC5B,8OAAC;;0DACC,8OAAC,mJAAA,CAAA,QAAK;gDAAC,SAAQ;gDAAW,WAAU;0DAAsD;;;;;;0DAC1F,8OAAC,sJAAA,CAAA,WAAQ;gDAAC,IAAG;gDAAW,aAAY;gDAA8C,OAAO;gDAAgB,UAAU,CAAC,IAAM,kBAAkB,EAAE,MAAM,CAAC,KAAK;gDAAG,UAAU;gDAAW,MAAM;gDAAG,WAAU;;;;;;;;;;;;kDAEvM,8OAAC;;0DACC,8OAAC,mJAAA,CAAA,QAAK;gDAAC,SAAQ;gDAAW,WAAU;0DAAsD;;;;;;0DAC1F,8OAAC,sJAAA,CAAA,WAAQ;gDAAC,IAAG;gDAAW,aAAY;gDAA4B,OAAO;gDAAgB,UAAU,CAAC,IAAM,kBAAkB,EAAE,MAAM,CAAC,KAAK;gDAAG,UAAU;gDAAW,MAAM;gDAAG,WAAU;;;;;;;;;;;;;;4BAMxL,iCACC;;oCACG,iBAAiB,SAAS;oCAC1B,iBAAiB,OAAO;kDACzB,8OAAC;;0DACC,8OAAC,mJAAA,CAAA,QAAK;gDAAC,SAAQ;gDAAS,WAAU;0DAAsD;;;;;;0DACxF,8OAAC,sJAAA,CAAA,WAAQ;gDAAC,IAAG;gDAAS,aAAY;gDAA8E,OAAO;gDAAQ,UAAU,CAAC,IAAM,UAAU,EAAE,MAAM,CAAC,KAAK;gDAAG,UAAU;gDAAW,MAAM;gDAAG,WAAU;;;;;;;;;;;;kDAErN,8OAAC;wCAAI,WAAU;;0DACb,8OAAC;;kEACC,8OAAC,mJAAA,CAAA,QAAK;wDAAC,SAAQ;wDAAa,WAAU;kEAAoD;;;;;;kEAC1F,8OAAC,mJAAA,CAAA,QAAK;wDAAC,MAAK;wDAAS,IAAG;wDAAa,OAAO;wDAAY,UAAU,CAAC,IAAM,cAAc,SAAS,EAAE,MAAM,CAAC,KAAK,KAAK;wDAAM,KAAK;wDAAK,KAAK;wDAAM,MAAM;wDAAI,UAAU;wDAAW,WAAU;;;;;;;;;;;;0DAEzL,8OAAC;;kEACC,8OAAC,mJAAA,CAAA,QAAK;wDAAC,SAAQ;wDAAc,WAAU;kEAAoD;;;;;;kEAC3F,8OAAC,mJAAA,CAAA,QAAK;wDAAC,MAAK;wDAAS,IAAG;wDAAc,OAAO;wDAAa,UAAU,CAAC,IAAM,eAAe,SAAS,EAAE,MAAM,CAAC,KAAK,KAAK;wDAAM,KAAK;wDAAK,KAAK;wDAAM,MAAM;wDAAI,UAAU;wDAAW,WAAU;;;;;;;;;;;;0DAE5L,8OAAC;;kEACC,8OAAC,mJAAA,CAAA,QAAK;wDAAC,SAAQ;wDAAc,WAAU;kEAAoD;;;;;;kEAC3F,8OAAC,mJAAA,CAAA,QAAK;wDAAC,MAAK;wDAAS,IAAG;wDAAc,OAAO;wDAAa,UAAU,CAAC,IAAM,eAAe,SAAS,EAAE,MAAM,CAAC,KAAK,KAAK;wDAAK,KAAK;wDAAI,KAAK;wDAAK,MAAM;wDAAG,UAAU;wDAAW,WAAU;;;;;;;;;;;;;;;;;;;;0CAM9L,8OAAC,oJAAA,CAAA,SAAM;gCACL,MAAK;gCACL,UACE,aACA,CAAC,UACD,cAAc,cACb,cAAc,CAAC,OAAO,IAAI,MAC1B,cAAc,CAAC,cAAc,CAAC,aAC9B,mBAAmB,CAAC,AAAC,CAAC,kBAAkB,CAAC,iBAAmB,CAAC,gBAAgB,CAAC,eAAgB,CAAC,OAAO,IAAI,EAAE;gCAE/G,WAAU;0CAET,0BAAc;;sDAAE,8OAAC,iNAAA,CAAA,UAAO;4CAAC,WAAU;;;;;;wCAA8B;wCAAE,eAAe,gBAAgB;;iEAA0B;;sDAAE,8OAAC,0MAAA,CAAA,WAAQ;4CAAC,WAAU;;;;;;wCAAiB;wCAAY;wCAAW;;;;;;;;;;;;;;kCAG/L,8OAAC;wBAAI,WAAU;;0CACb,8OAAC;;kDAAE,8OAAC;wCAAK,WAAU;kDAAmC;;;;;;oCAAY;kDAAC,8OAAC;wCAAK,WAAU;kDAA4B;;;;;;oCAAkB;;;;;;;0CACjI,8OAAC;;kDAAE,8OAAC;wCAAK,WAAU;kDAAmC;;;;;;oCAAiB;kDAAC,8OAAC;wCAAK,WAAU;kDAA4B,YAAY,cAAc;;;;;;oCAAU;;;;;;;4BACvJ,cAAc,cAAc,CAAC,2BAAe,8OAAC;gCAAE,WAAU;;kDAAwD,8OAAC,oNAAA,CAAA,cAAW;wCAAC,WAAU;;;;;;oCAAW;;;;;;;;;;;;;;;;;;;0BAKxJ,8OAAC,0LAAA,CAAA,SAAM,CAAC,GAAG;gBAAC,SAAS;oBAAE,SAAS;oBAAG,GAAG;gBAAG;gBAAG,SAAS;oBAAE,SAAS;oBAAG,GAAG;gBAAE;gBAAG,YAAY;oBAAE,UAAU;oBAAK,OAAO;gBAAI;gBAAG,WAAU;;kCAC9H,8OAAC;wBAAM,WAAU;kCAAsD;;;;;;kCACvE,8OAAC;wBAAI,WAAU;kCACb,cAAA,8OAAC,yLAAA,CAAA,kBAAe;4BAAC,MAAK;;gCAEnB,aAAa,CAAC,kBAAkB,aAAa,kBAAkB,YAAY,mBAC1E,8OAAC,0LAAA,CAAA,SAAM,CAAC,GAAG;oCAAe,SAAS;wCAAE,SAAS;wCAAG,OAAO;oCAAI;oCAAG,SAAS;wCAAE,SAAS;wCAAG,OAAO;oCAAE;oCAAG,MAAM;wCAAE,SAAS;wCAAG,OAAO;oCAAI;oCAAG,YAAY;wCAAE,UAAU;oCAAI;oCAAG,WAAU;;wCAAqH;sDAAC,8OAAC,iNAAA,CAAA,UAAO;4CAAC,WAAU;;;;;;wCAA6C;sDAAC,8OAAC;4CAAE,WAAU;;gDAAwC;gDAAiB;gDAAmB;;;;;;;wCAAO;sDAAC,8OAAC;4CAAE,WAAU;sDAAqC;;;;;;wCAAsB;;mCAA7f;;;;;gCAGjB,kBAAkB,eAAe,4BAChC,8OAAC,0LAAA,CAAA,SAAM,CAAC,GAAG;oCAAiB,SAAS;wCAAE,SAAS;oCAAE;oCAAG,SAAS;wCAAE,SAAS;oCAAE;oCAAG,YAAY;wCAAE,UAAU;oCAAI;oCAAG,WAAU;8CACpH,uBAAuB,wBAAY,8OAAC;wCAAM,KAAK;wCAAY,QAAQ;wCAAC,WAAU;wCAA0C,SAAQ;;;;;6DAAoB,8OAAC,6HAAA,CAAA,UAAK;wCAAC,KAAK;wCAAY,KAAK,UAAU;wCAAmB,IAAI;wCAAC,WAAU;wCAA4B,aAAa;;;;;;mCADzP;;;;;gCAKjB,kBAAkB,YAAY,CAAC,2BAC9B,8OAAC,0LAAA,CAAA,SAAM,CAAC,GAAG;oCAAc,SAAS;wCAAE,SAAS;wCAAG,GAAG;oCAAG;oCAAG,SAAS;wCAAE,SAAS;wCAAG,GAAG;oCAAE;oCAAG,MAAM;wCAAE,SAAS;wCAAG,GAAG;oCAAG;oCAAG,YAAY;wCAAE,UAAU;oCAAI;oCAAG,WAAU;;wCAA2H;sDAAC,8OAAC,oNAAA,CAAA,cAAW;4CAAC,WAAU;;;;;;wCAA+C;sDAAC,8OAAC;4CAAE,WAAU;sDAAoD;;;;;;wCAAsB;sDAAC,8OAAC;4CAAE,WAAU;sDAA8C;;;;;;wCAA+B;;mCAAngB;;;;;gCAGjB,kBAAkB,UAAU,CAAC,2BAC5B,8OAAC,0LAAA,CAAA,SAAM,CAAC,GAAG;oCAAY,SAAS;wCAAE,SAAS;oCAAE;oCAAG,SAAS;wCAAE,SAAS;oCAAE;oCAAG,YAAY;wCAAE,UAAU;oCAAI;oCAAG,WAAU;;wCAAkF;sDAAC,8OAAC;4CAAI,WAAU;;gDAAuF;gDAAE,uBAAuB,wBAAU,8OAAC,oMAAA,CAAA,QAAW;oDAAC,WAAU;;;;;yEAAiC,8OAAC,kMAAA,CAAA,OAAI;oDAAC,WAAU;;;;;;gDAA+B;;;;;;;wCAAO;sDAAC,8OAAC;4CAAE,WAAU;;gDAAY;gDAAO;gDAAmB;;;;;;;wCAA8B;;mCAA9f;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAO9B","debugId":null}},
    {"offset": {"line": 1726, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/lib/actions/media.actions.ts"],"sourcesContent":["// src/lib/actions/media.actions.ts\r\n'use server';\r\n\r\nimport { createClient } from '@repo/supabase/server';\r\nimport { useCredits } from '@/lib/credits';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { MediaType, CREDIT_COSTS, GenerationResult, GenerationMode } from '@/lib/constants/media';\r\n// Import the specific Insert type and GeneratedMedia type\r\nimport { Database, GeneratedMedia } from '@/types/db_types';\r\nimport { supabaseAdmin } from '@repo/supabase/admin';\r\n// Import only the necessary storage service functions (used by actions below)\r\nimport { listUserFiles as listUserFilesService, deleteFile as deleteFileService } from '@/lib/storage/supabase-storage';\r\n// Import Pixio API client and models\r\nimport {\r\n  PIXIO_MODELS,\r\n  queuePixioRun,\r\n  cancelPixioRun,\r\n  createRunRequest,\r\n  type KreaFluxInputs,\r\n  type WanFirstLastFrameInputs\r\n} from '@repo/pixio-api';\r\n\r\n// Define the specific type for insertion, derived from db_types.ts\r\ntype GeneratedMediaInsert = Database['public']['Tables']['generated_media']['Insert'];\r\n\r\n/**\r\n * Initiates media generation by creating a record and invoking the Supabase Function.\r\n * Expects image URLs for modes that require input images (client handles upload).\r\n */\r\nexport async function generateMedia(formData: FormData): Promise<{\r\n  success: boolean;\r\n  mediaId?: string;\r\n  error?: string;\r\n}> {\r\n  const supabase = await createClient();\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n\r\n  if (!user || userError) {\r\n    return { success: false, error: 'Authentication error' };\r\n  }\r\n\r\n  // --- Read data from FormData ---\r\n  const generationMode = formData.get('generationMode') as GenerationMode;\r\n  \r\n  // Determine media type based on model category, not generation mode name\r\n  const mediaType: MediaType = generationMode === 'firstLastFrameVideo' ? 'video' : 'image';\r\n  // Krea Flux (image mode) → image\r\n  // Qwen Edit (video mode) → image (it's editing, not generating video)\r\n  // Wan 2.2 (firstLastFrameVideo mode) → video\r\n\r\n  // --- Validation ---\r\n  if (!generationMode) {\r\n    return { success: false, error: 'Missing required fields' };\r\n  }\r\n\r\n  // Mode-specific input extraction and validation\r\n  let prompt = '';\r\n  let startImageUrl: string | null = null;\r\n  let endImageUrl: string | null = null;\r\n  let image1Url: string | null = null;\r\n  let image2Url: string | null = null;\r\n  let image3Url: string | null = null;\r\n  let positivePrompt = '';\r\n  let negativePrompt = '';\r\n  let width = 1024;\r\n  let height = 1024;\r\n  let videoWidth = 512;\r\n  let videoHeight = 512;\r\n  let videoLength = 81;\r\n\r\n  if (generationMode === 'image') {\r\n    // Krea Flux\r\n    prompt = formData.get('prompt') as string;\r\n    width = parseInt(formData.get('width') as string) || 1024;\r\n    height = parseInt(formData.get('height') as string) || 1024;\r\n    if (!prompt?.trim()) return { success: false, error: 'Missing prompt' };\r\n  } else if (generationMode === 'video') {\r\n    // Qwen Edit\r\n    image1Url = formData.get('image1Url') as string;\r\n    image2Url = formData.get('image2Url') as string || null;\r\n    image3Url = formData.get('image3Url') as string || null;\r\n    positivePrompt = formData.get('positivePrompt') as string || '';\r\n    negativePrompt = formData.get('negativePrompt') as string || '';\r\n    if (!image1Url) return { success: false, error: 'Missing image for editing' };\r\n  } else if (generationMode === 'firstLastFrameVideo') {\r\n    // Wan 2.2\r\n    prompt = formData.get('prompt') as string;\r\n    startImageUrl = formData.get('startImageUrl') as string;\r\n    endImageUrl = formData.get('endImageUrl') as string;\r\n    videoWidth = parseInt(formData.get('width') as string) || 512;\r\n    videoHeight = parseInt(formData.get('height') as string) || 512;\r\n    videoLength = parseInt(formData.get('length') as string) || 81;\r\n    if (!prompt?.trim()) return { success: false, error: 'Missing prompt' };\r\n    if (!startImageUrl) return { success: false, error: 'Missing start image URL' };\r\n    if (!endImageUrl) return { success: false, error: 'Missing end image URL' };\r\n  }\r\n\r\n  const creditCost = CREDIT_COSTS[generationMode];\r\n  if (creditCost === undefined) {\r\n    return { success: false, error: 'Invalid generation mode' };\r\n  }\r\n\r\n  try {\r\n    // 1. Check and deduct credits\r\n    const creditSuccess = await useCredits(\r\n      user.id,\r\n      creditCost,\r\n      `Generate ${generationMode}: \"${prompt.slice(0, 30)}${prompt.length > 30 ? '...' : ''}\"`\r\n    );\r\n    if (!creditSuccess) { return { success: false, error: 'Not enough credits' }; }\r\n    console.log(`[Action] Credits deducted successfully for user ${user.id}`);\r\n\r\n    // 2. Create initial 'pending' record in DB\r\n    const insertPayload: GeneratedMediaInsert = {\r\n        user_id: user.id,\r\n        prompt: prompt || positivePrompt || 'Image edit', // Use appropriate prompt\r\n        media_type: mediaType,\r\n        credits_used: creditCost,\r\n        status: 'pending',\r\n        media_url: '', // Required by Insert type\r\n        storage_path: '', // Required by Insert type\r\n        metadata: {\r\n          generationMode,\r\n          ...(generationMode === 'image' && { width, height }),\r\n          ...(positivePrompt && { positivePrompt, negativePrompt })\r\n        }\r\n    };\r\n    if (generationMode === 'firstLastFrameVideo') {\r\n        insertPayload.start_image_url = startImageUrl;\r\n        insertPayload.end_image_url = endImageUrl;\r\n    }\r\n    const { data: newMediaRecord, error: insertError } = await supabaseAdmin\r\n      .from('generated_media').insert(insertPayload).select('id').single();\r\n    if (insertError || !newMediaRecord) {\r\n      console.error(\"[Action] Failed to insert initial media record:\", insertError);\r\n      // TODO: Consider refunding credits here if insert fails after deduction\r\n      return { success: false, error: `Failed to create generation record: ${insertError?.message}` };\r\n    }\r\n    const mediaId = newMediaRecord.id;\r\n    console.log(`[Action] Initial media record created with ID: ${mediaId}`);\r\n\r\n    // 3. Prepare webhook URL for Pixio API callbacks\r\n    const webhookUrl = `${process.env.NEXT_PUBLIC_SITE_URL}/api/webhooks/pixio`;\r\n    console.log(`[Action] Using webhook URL: ${webhookUrl}`);\r\n\r\n    // 4. Get API key\r\n    const apiKey = process.env.PIXIO_DEPLOY_API_KEY;\r\n    if (!apiKey) {\r\n      console.error('[Action] PIXIO_DEPLOY_API_KEY not configured');\r\n      return { success: false, error: 'API key not configured' };\r\n    }\r\n\r\n    // 5. Select model and call Pixio API based on generation mode\r\n    let pixioResult;\r\n    let selectedModel;\r\n\r\n    if (generationMode === 'image') {\r\n      // Use Krea Flux model\r\n      selectedModel = PIXIO_MODELS.kreaFlux;\r\n      const inputs: KreaFluxInputs = {\r\n        text: prompt,\r\n        width,\r\n        height\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else if (generationMode === 'video') {\r\n      // Use Qwen Edit model\r\n      selectedModel = PIXIO_MODELS.qwenEdit;\r\n      const inputs: import('@repo/pixio-api').QwenEditInputs = {\r\n        image1: image1Url!,\r\n        positive: positivePrompt,\r\n        negative: negativePrompt,\r\n        ...(image2Url && { image2: image2Url }),\r\n        ...(image3Url && { image3: image3Url })\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else if (generationMode === 'firstLastFrameVideo') {\r\n      // Use Wan First/Last Frame model\r\n      selectedModel = PIXIO_MODELS.wanFirstLastFrame;\r\n      const inputs: WanFirstLastFrameInputs = {\r\n        start_image: startImageUrl!,\r\n        end_image: endImageUrl!,\r\n        positive: prompt, // Wan uses 'positive' not 'prompt'\r\n        negative: '',\r\n        width: videoWidth,\r\n        height: videoHeight,\r\n        length: videoLength\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else {\r\n      console.error(`[Action] Unsupported generation mode: ${generationMode}`);\r\n      return { success: false, error: 'Unsupported generation mode' };\r\n    }\r\n\r\n    // 6. Check Pixio API result\r\n\r\n    if (!pixioResult.success || !pixioResult.data) {\r\n      console.error(`[Action] Pixio API error:`, pixioResult.error);\r\n      \r\n      // Update record to failed\r\n      await supabaseAdmin\r\n        .from('generated_media')\r\n        .update({\r\n          status: 'failed',\r\n          metadata: {\r\n            error: pixioResult.error || 'API request failed',\r\n            failed_at: new Date().toISOString()\r\n          }\r\n        })\r\n        .eq('id', mediaId);\r\n      \r\n      return { success: false, error: pixioResult.error || 'API request failed' };\r\n    }\r\n\r\n    const runId = pixioResult.data.run_id;\r\n\r\n    console.log(`[Action] Pixio API run started with ID: ${runId} using model: ${selectedModel.name}`);\r\n\r\n    // 7. Update record with run_id, model info, and processing status\r\n    const { error: runIdUpdateError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .update({\r\n        status: 'processing',\r\n        metadata: {\r\n          run_id: runId,\r\n          generationMode,\r\n          model_id: selectedModel.id,\r\n          model_name: selectedModel.name,\r\n          started_at: new Date().toISOString()\r\n        }\r\n      })\r\n      .eq('id', mediaId);\r\n\r\n    if (runIdUpdateError) {\r\n      console.error(`[Action] Error updating record with run_id:`, runIdUpdateError);\r\n    }\r\n\r\n    // 8. Revalidate path to show processing state\r\n    revalidatePath('/dashboard');\r\n\r\n    // 9. Return success (webhook will handle completion)\r\n    console.log(`[Action] Successfully initiated generation for ${mediaId}`);\r\n    return { success: true, mediaId: mediaId };\r\n\r\n  } catch (error: any) {\r\n    console.error('[Action] Error in generateMedia action:', error);\r\n    // If the error happened before invocation (e.g., credit deduction), return error\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Cancels a running media generation\r\n */\r\nexport async function cancelGeneration(mediaId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  if (!mediaId) {\r\n    return { success: false, error: 'Media ID is required' };\r\n  }\r\n\r\n  const supabase = await createClient();\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n\r\n  if (!user || userError) {\r\n    return { success: false, error: 'Authentication error' };\r\n  }\r\n\r\n  console.log(`[Action] Cancelling generation for mediaId: ${mediaId}`);\r\n\r\n  try {\r\n    // Fetch the media record to verify ownership and get run_id\r\n    const { data: mediaRecord, error: fetchError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .select('id, user_id, status, metadata')\r\n      .eq('id', mediaId)\r\n      .single();\r\n\r\n    if (fetchError || !mediaRecord) {\r\n      console.error(`[Action] Error fetching media ${mediaId}:`, fetchError);\r\n      return { success: false, error: 'Media record not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    if (mediaRecord.user_id !== user.id) {\r\n      console.warn(`[Action] User ${user.id} attempted to cancel media ${mediaId} owned by ${mediaRecord.user_id}`);\r\n      return { success: false, error: 'Permission denied' };\r\n    }\r\n\r\n    // Check if cancellable\r\n    if (!['pending', 'processing'].includes(mediaRecord.status)) {\r\n      return { success: false, error: `Cannot cancel ${mediaRecord.status} generation` };\r\n    }\r\n\r\n    // Get run_id from metadata\r\n    const runId = (mediaRecord.metadata as any)?.run_id;\r\n    \r\n    if (!runId) {\r\n      // No run_id yet, just update status to failed\r\n      console.log(`[Action] No run_id for ${mediaId}, marking as cancelled locally`);\r\n      \r\n      const { error: updateError } = await supabaseAdmin\r\n        .from('generated_media')\r\n        .update({\r\n          status: 'failed',\r\n          metadata: {\r\n            ...(mediaRecord.metadata as object || {}),\r\n            error: 'Cancelled by user',\r\n            cancelled_at: new Date().toISOString()\r\n          }\r\n        })\r\n        .eq('id', mediaId);\r\n\r\n      if (updateError) {\r\n        console.error('[Action] Error updating cancelled status:', updateError);\r\n        return { success: false, error: 'Failed to cancel generation' };\r\n      }\r\n\r\n      revalidatePath('/dashboard');\r\n      return { success: true };\r\n    }\r\n\r\n    // Call Pixio API to cancel the run using the client\r\n    console.log(`[Action] Calling Pixio API to cancel run: ${runId}`);\r\n    \r\n    const apiKey = process.env.PIXIO_DEPLOY_API_KEY;\r\n    if (!apiKey) {\r\n      return { success: false, error: 'API key not configured' };\r\n    }\r\n\r\n    const cancelResult = await cancelPixioRun(runId, apiKey);\r\n\r\n    // Note: Even if the cancel API call fails, we still mark it as cancelled locally\r\n    if (!cancelResult.success) {\r\n      console.warn(`[Action] Pixio cancel API failed: ${cancelResult.error}, but continuing with local cancellation`);\r\n    }\r\n\r\n    // Update database to cancelled/failed status\r\n    const { error: updateError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .update({\r\n        status: 'failed',\r\n        metadata: {\r\n          ...(mediaRecord.metadata as object || {}),\r\n          error: 'Cancelled by user',\r\n          cancelled_at: new Date().toISOString(),\r\n          cancel_api_status: cancelResult.success ? 'success' : 'failed'\r\n        }\r\n      })\r\n      .eq('id', mediaId);\r\n\r\n    if (updateError) {\r\n      console.error('[Action] Error updating cancelled status:', updateError);\r\n      return { success: false, error: 'Failed to update cancellation status' };\r\n    }\r\n\r\n    console.log(`[Action] Successfully cancelled generation ${mediaId}`);\r\n    revalidatePath('/dashboard');\r\n    return { success: true };\r\n\r\n  } catch (error: any) {\r\n    console.error(`[Action] Error cancelling generation ${mediaId}:`, error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Deletes a media item record and its associated file from storage.\r\n */\r\nexport async function deleteMedia(mediaId: string, storagePath: string | null): Promise<{\r\n    success: boolean;\r\n    error?: string;\r\n  }> {\r\n    if (!mediaId) { return { success: false, error: \"Media ID is required.\" }; }\r\n    const supabase = await createClient(); // Use server client to get user\r\n    const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n    if (!user || userError) { return { success: false, error: 'Authentication error' }; }\r\n\r\n    console.log(`[Action] Deleting media ${mediaId} (path: ${storagePath || 'N/A'}) for user ${user.id}`);\r\n    try {\r\n      // Verify ownership using admin client\r\n      const { data: mediaRecord, error: fetchError } = await supabaseAdmin\r\n        .from('generated_media').select('id, user_id, storage_path').eq('id', mediaId).single();\r\n      if (fetchError || !mediaRecord) { console.error(`[Action] Error fetching media ${mediaId} for deletion or not found:`, fetchError); return { success: false, error: 'Media record not found.' }; }\r\n      if (mediaRecord.user_id !== user.id) { console.warn(`[Action] User ${user.id} attempted to delete media ${mediaId} owned by ${mediaRecord.user_id}. Denying.`); return { success: false, error: 'Permission denied.' }; }\r\n\r\n      const actualStoragePath = mediaRecord.storage_path;\r\n\r\n      // Delete from Storage *only if path exists* using the service function\r\n      if (actualStoragePath) {\r\n        console.log(`[Action] Calling service to delete file from storage: ${actualStoragePath}`);\r\n        const { success: deleteSuccess, error: deleteError } = await deleteFileService(actualStoragePath); // Use storage service\r\n        if (!deleteSuccess) { console.error(`[Action] Error deleting file ${actualStoragePath} from storage (continuing):`, deleteError); }\r\n        else { console.log(`[Action] Successfully deleted file ${actualStoragePath} via service.`); }\r\n      } else { console.log(`[Action] No storage path for media ${mediaId}, skipping storage deletion.`); }\r\n\r\n      // Delete from Database using admin client\r\n      console.log(`[Action] Deleting record from database: ${mediaId}`);\r\n      const { error: dbError } = await supabaseAdmin.from('generated_media').delete().eq('id', mediaId);\r\n      if (dbError) { console.error(`[Action] Error deleting record ${mediaId} from database:`, dbError); throw new Error(`Database deletion failed: ${dbError.message}`); }\r\n      console.log(`[Action] Successfully deleted record ${mediaId} from database.`);\r\n\r\n      revalidatePath('/dashboard');\r\n      return { success: true };\r\n    } catch (error: any) {\r\n      console.error(`[Action] Unexpected error during media deletion for ${mediaId}:`, error);\r\n      return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n/**\r\n * Fetches completed and processing media items for the current user.\r\n */\r\nexport async function fetchUserMedia(): Promise<{\r\n  success: boolean;\r\n  media: GeneratedMedia[];\r\n  error?: string;\r\n}> {\r\n  const supabase = await createClient(); // Uses server client\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n  if (!user || userError) { return { success: false, error: 'Authentication error', media: [] }; }\r\n\r\n  try {\r\n    // Use user-context client for RLS\r\n    const { data, error } = await supabase\r\n      .from('generated_media')\r\n      .select('*')\r\n      .eq('user_id', user.id)\r\n      .in('status', ['pending', 'processing', 'completed', 'failed'])\r\n      .order('created_at', { ascending: false })\r\n      .limit(50); // Adjust limit as needed\r\n\r\n    if (error) { throw new Error(`Failed to fetch media: ${error.message}`); }\r\n    return { success: true, media: data || [], error: undefined };\r\n  } catch (error: any) {\r\n    console.error('[Action] Error fetching user media:', error);\r\n    return { success: false, error: error.message, media: [] };\r\n  }\r\n}\r\n\r\n/**\r\n * Server Action to list user's generated images and input images for selection.\r\n */\r\nexport async function listUserImagesForSelection(): Promise<{\r\n    success: boolean;\r\n    images: { value: string; label: string; type: 'generated' | 'input' }[];\r\n    error?: string;\r\n}> {\r\n    const supabase = await createClient(); // Use server client to get user\r\n    const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n    if (!user || userError) { return { success: false, images: [], error: 'Authentication error' }; }\r\n\r\n    try {\r\n        const [generatedResult, inputResult] = await Promise.all([\r\n            // Fetch completed generated images using RLS-enabled client\r\n            supabase\r\n                .from('generated_media')\r\n                .select('id, prompt, media_url')\r\n                .eq('user_id', user.id)\r\n                .eq('media_type', 'image')\r\n                .eq('status', 'completed')\r\n                .not('media_url', 'is', null)\r\n                .order('created_at', { ascending: false })\r\n                .limit(50), // Limit generated images shown\r\n            // Fetch input images using the service function (uses admin client)\r\n            listUserFilesService(user.id, 'inputs')\r\n        ]);\r\n\r\n        const fetchedImages: { value: string; label: string; type: 'generated' | 'input' }[] = [];\r\n\r\n        // Process generated images\r\n        if (generatedResult.error) { console.error(\"[Action] Error fetching generated images:\", generatedResult.error); }\r\n        else if (generatedResult.data) { generatedResult.data.forEach(item => { fetchedImages.push({ value: item.media_url!, label: item.prompt ? `Gen: ${item.prompt.substring(0, 30)}...` : `Generated Image ${item.id.substring(0, 6)}`, type: 'generated', }); }); }\r\n\r\n        // Process input images\r\n        if (!inputResult.success) { console.error(\"[Action] Error fetching input images:\", inputResult.error); }\r\n        else if (inputResult.files) { inputResult.files.forEach(file => { if (file.publicUrl && /\\.(jpg|jpeg|png|webp|gif)$/i.test(file.name)) { fetchedImages.push({ value: file.publicUrl, label: `Input: ${file.name}`, type: 'input', }); } }); }\r\n\r\n        fetchedImages.sort((a, b) => a.label.localeCompare(b.label));\r\n        return { success: true, images: fetchedImages };\r\n\r\n    } catch (error: any) {\r\n        console.error('[Action] Error listing user images:', error);\r\n        return { success: false, images: [], error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;IAuYsB,cAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 1739, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/lib/actions/media.actions.ts"],"sourcesContent":["// src/lib/actions/media.actions.ts\r\n'use server';\r\n\r\nimport { createClient } from '@repo/supabase/server';\r\nimport { useCredits } from '@/lib/credits';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { MediaType, CREDIT_COSTS, GenerationResult, GenerationMode } from '@/lib/constants/media';\r\n// Import the specific Insert type and GeneratedMedia type\r\nimport { Database, GeneratedMedia } from '@/types/db_types';\r\nimport { supabaseAdmin } from '@repo/supabase/admin';\r\n// Import only the necessary storage service functions (used by actions below)\r\nimport { listUserFiles as listUserFilesService, deleteFile as deleteFileService } from '@/lib/storage/supabase-storage';\r\n// Import Pixio API client and models\r\nimport {\r\n  PIXIO_MODELS,\r\n  queuePixioRun,\r\n  cancelPixioRun,\r\n  createRunRequest,\r\n  type KreaFluxInputs,\r\n  type WanFirstLastFrameInputs\r\n} from '@repo/pixio-api';\r\n\r\n// Define the specific type for insertion, derived from db_types.ts\r\ntype GeneratedMediaInsert = Database['public']['Tables']['generated_media']['Insert'];\r\n\r\n/**\r\n * Initiates media generation by creating a record and invoking the Supabase Function.\r\n * Expects image URLs for modes that require input images (client handles upload).\r\n */\r\nexport async function generateMedia(formData: FormData): Promise<{\r\n  success: boolean;\r\n  mediaId?: string;\r\n  error?: string;\r\n}> {\r\n  const supabase = await createClient();\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n\r\n  if (!user || userError) {\r\n    return { success: false, error: 'Authentication error' };\r\n  }\r\n\r\n  // --- Read data from FormData ---\r\n  const generationMode = formData.get('generationMode') as GenerationMode;\r\n  \r\n  // Determine media type based on model category, not generation mode name\r\n  const mediaType: MediaType = generationMode === 'firstLastFrameVideo' ? 'video' : 'image';\r\n  // Krea Flux (image mode) → image\r\n  // Qwen Edit (video mode) → image (it's editing, not generating video)\r\n  // Wan 2.2 (firstLastFrameVideo mode) → video\r\n\r\n  // --- Validation ---\r\n  if (!generationMode) {\r\n    return { success: false, error: 'Missing required fields' };\r\n  }\r\n\r\n  // Mode-specific input extraction and validation\r\n  let prompt = '';\r\n  let startImageUrl: string | null = null;\r\n  let endImageUrl: string | null = null;\r\n  let image1Url: string | null = null;\r\n  let image2Url: string | null = null;\r\n  let image3Url: string | null = null;\r\n  let positivePrompt = '';\r\n  let negativePrompt = '';\r\n  let width = 1024;\r\n  let height = 1024;\r\n  let videoWidth = 512;\r\n  let videoHeight = 512;\r\n  let videoLength = 81;\r\n\r\n  if (generationMode === 'image') {\r\n    // Krea Flux\r\n    prompt = formData.get('prompt') as string;\r\n    width = parseInt(formData.get('width') as string) || 1024;\r\n    height = parseInt(formData.get('height') as string) || 1024;\r\n    if (!prompt?.trim()) return { success: false, error: 'Missing prompt' };\r\n  } else if (generationMode === 'video') {\r\n    // Qwen Edit\r\n    image1Url = formData.get('image1Url') as string;\r\n    image2Url = formData.get('image2Url') as string || null;\r\n    image3Url = formData.get('image3Url') as string || null;\r\n    positivePrompt = formData.get('positivePrompt') as string || '';\r\n    negativePrompt = formData.get('negativePrompt') as string || '';\r\n    if (!image1Url) return { success: false, error: 'Missing image for editing' };\r\n  } else if (generationMode === 'firstLastFrameVideo') {\r\n    // Wan 2.2\r\n    prompt = formData.get('prompt') as string;\r\n    startImageUrl = formData.get('startImageUrl') as string;\r\n    endImageUrl = formData.get('endImageUrl') as string;\r\n    videoWidth = parseInt(formData.get('width') as string) || 512;\r\n    videoHeight = parseInt(formData.get('height') as string) || 512;\r\n    videoLength = parseInt(formData.get('length') as string) || 81;\r\n    if (!prompt?.trim()) return { success: false, error: 'Missing prompt' };\r\n    if (!startImageUrl) return { success: false, error: 'Missing start image URL' };\r\n    if (!endImageUrl) return { success: false, error: 'Missing end image URL' };\r\n  }\r\n\r\n  const creditCost = CREDIT_COSTS[generationMode];\r\n  if (creditCost === undefined) {\r\n    return { success: false, error: 'Invalid generation mode' };\r\n  }\r\n\r\n  try {\r\n    // 1. Check and deduct credits\r\n    const creditSuccess = await useCredits(\r\n      user.id,\r\n      creditCost,\r\n      `Generate ${generationMode}: \"${prompt.slice(0, 30)}${prompt.length > 30 ? '...' : ''}\"`\r\n    );\r\n    if (!creditSuccess) { return { success: false, error: 'Not enough credits' }; }\r\n    console.log(`[Action] Credits deducted successfully for user ${user.id}`);\r\n\r\n    // 2. Create initial 'pending' record in DB\r\n    const insertPayload: GeneratedMediaInsert = {\r\n        user_id: user.id,\r\n        prompt: prompt || positivePrompt || 'Image edit', // Use appropriate prompt\r\n        media_type: mediaType,\r\n        credits_used: creditCost,\r\n        status: 'pending',\r\n        media_url: '', // Required by Insert type\r\n        storage_path: '', // Required by Insert type\r\n        metadata: {\r\n          generationMode,\r\n          ...(generationMode === 'image' && { width, height }),\r\n          ...(positivePrompt && { positivePrompt, negativePrompt })\r\n        }\r\n    };\r\n    if (generationMode === 'firstLastFrameVideo') {\r\n        insertPayload.start_image_url = startImageUrl;\r\n        insertPayload.end_image_url = endImageUrl;\r\n    }\r\n    const { data: newMediaRecord, error: insertError } = await supabaseAdmin\r\n      .from('generated_media').insert(insertPayload).select('id').single();\r\n    if (insertError || !newMediaRecord) {\r\n      console.error(\"[Action] Failed to insert initial media record:\", insertError);\r\n      // TODO: Consider refunding credits here if insert fails after deduction\r\n      return { success: false, error: `Failed to create generation record: ${insertError?.message}` };\r\n    }\r\n    const mediaId = newMediaRecord.id;\r\n    console.log(`[Action] Initial media record created with ID: ${mediaId}`);\r\n\r\n    // 3. Prepare webhook URL for Pixio API callbacks\r\n    const webhookUrl = `${process.env.NEXT_PUBLIC_SITE_URL}/api/webhooks/pixio`;\r\n    console.log(`[Action] Using webhook URL: ${webhookUrl}`);\r\n\r\n    // 4. Get API key\r\n    const apiKey = process.env.PIXIO_DEPLOY_API_KEY;\r\n    if (!apiKey) {\r\n      console.error('[Action] PIXIO_DEPLOY_API_KEY not configured');\r\n      return { success: false, error: 'API key not configured' };\r\n    }\r\n\r\n    // 5. Select model and call Pixio API based on generation mode\r\n    let pixioResult;\r\n    let selectedModel;\r\n\r\n    if (generationMode === 'image') {\r\n      // Use Krea Flux model\r\n      selectedModel = PIXIO_MODELS.kreaFlux;\r\n      const inputs: KreaFluxInputs = {\r\n        text: prompt,\r\n        width,\r\n        height\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else if (generationMode === 'video') {\r\n      // Use Qwen Edit model\r\n      selectedModel = PIXIO_MODELS.qwenEdit;\r\n      const inputs: import('@repo/pixio-api').QwenEditInputs = {\r\n        image1: image1Url!,\r\n        positive: positivePrompt,\r\n        negative: negativePrompt,\r\n        ...(image2Url && { image2: image2Url }),\r\n        ...(image3Url && { image3: image3Url })\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else if (generationMode === 'firstLastFrameVideo') {\r\n      // Use Wan First/Last Frame model\r\n      selectedModel = PIXIO_MODELS.wanFirstLastFrame;\r\n      const inputs: WanFirstLastFrameInputs = {\r\n        start_image: startImageUrl!,\r\n        end_image: endImageUrl!,\r\n        positive: prompt, // Wan uses 'positive' not 'prompt'\r\n        negative: '',\r\n        width: videoWidth,\r\n        height: videoHeight,\r\n        length: videoLength\r\n      };\r\n      const request = createRunRequest(selectedModel, inputs, {\r\n        webhook: webhookUrl,\r\n        webhookIntermediateStatus: false\r\n      });\r\n      \r\n      console.log(`[Action] Calling Pixio API for mediaId: ${mediaId}, model: ${selectedModel.name}`);\r\n      pixioResult = await queuePixioRun(request, apiKey);\r\n      \r\n    } else {\r\n      console.error(`[Action] Unsupported generation mode: ${generationMode}`);\r\n      return { success: false, error: 'Unsupported generation mode' };\r\n    }\r\n\r\n    // 6. Check Pixio API result\r\n\r\n    if (!pixioResult.success || !pixioResult.data) {\r\n      console.error(`[Action] Pixio API error:`, pixioResult.error);\r\n      \r\n      // Update record to failed\r\n      await supabaseAdmin\r\n        .from('generated_media')\r\n        .update({\r\n          status: 'failed',\r\n          metadata: {\r\n            error: pixioResult.error || 'API request failed',\r\n            failed_at: new Date().toISOString()\r\n          }\r\n        })\r\n        .eq('id', mediaId);\r\n      \r\n      return { success: false, error: pixioResult.error || 'API request failed' };\r\n    }\r\n\r\n    const runId = pixioResult.data.run_id;\r\n\r\n    console.log(`[Action] Pixio API run started with ID: ${runId} using model: ${selectedModel.name}`);\r\n\r\n    // 7. Update record with run_id, model info, and processing status\r\n    const { error: runIdUpdateError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .update({\r\n        status: 'processing',\r\n        metadata: {\r\n          run_id: runId,\r\n          generationMode,\r\n          model_id: selectedModel.id,\r\n          model_name: selectedModel.name,\r\n          started_at: new Date().toISOString()\r\n        }\r\n      })\r\n      .eq('id', mediaId);\r\n\r\n    if (runIdUpdateError) {\r\n      console.error(`[Action] Error updating record with run_id:`, runIdUpdateError);\r\n    }\r\n\r\n    // 8. Revalidate path to show processing state\r\n    revalidatePath('/dashboard');\r\n\r\n    // 9. Return success (webhook will handle completion)\r\n    console.log(`[Action] Successfully initiated generation for ${mediaId}`);\r\n    return { success: true, mediaId: mediaId };\r\n\r\n  } catch (error: any) {\r\n    console.error('[Action] Error in generateMedia action:', error);\r\n    // If the error happened before invocation (e.g., credit deduction), return error\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Cancels a running media generation\r\n */\r\nexport async function cancelGeneration(mediaId: string): Promise<{\r\n  success: boolean;\r\n  error?: string;\r\n}> {\r\n  if (!mediaId) {\r\n    return { success: false, error: 'Media ID is required' };\r\n  }\r\n\r\n  const supabase = await createClient();\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n\r\n  if (!user || userError) {\r\n    return { success: false, error: 'Authentication error' };\r\n  }\r\n\r\n  console.log(`[Action] Cancelling generation for mediaId: ${mediaId}`);\r\n\r\n  try {\r\n    // Fetch the media record to verify ownership and get run_id\r\n    const { data: mediaRecord, error: fetchError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .select('id, user_id, status, metadata')\r\n      .eq('id', mediaId)\r\n      .single();\r\n\r\n    if (fetchError || !mediaRecord) {\r\n      console.error(`[Action] Error fetching media ${mediaId}:`, fetchError);\r\n      return { success: false, error: 'Media record not found' };\r\n    }\r\n\r\n    // Verify ownership\r\n    if (mediaRecord.user_id !== user.id) {\r\n      console.warn(`[Action] User ${user.id} attempted to cancel media ${mediaId} owned by ${mediaRecord.user_id}`);\r\n      return { success: false, error: 'Permission denied' };\r\n    }\r\n\r\n    // Check if cancellable\r\n    if (!['pending', 'processing'].includes(mediaRecord.status)) {\r\n      return { success: false, error: `Cannot cancel ${mediaRecord.status} generation` };\r\n    }\r\n\r\n    // Get run_id from metadata\r\n    const runId = (mediaRecord.metadata as any)?.run_id;\r\n    \r\n    if (!runId) {\r\n      // No run_id yet, just update status to failed\r\n      console.log(`[Action] No run_id for ${mediaId}, marking as cancelled locally`);\r\n      \r\n      const { error: updateError } = await supabaseAdmin\r\n        .from('generated_media')\r\n        .update({\r\n          status: 'failed',\r\n          metadata: {\r\n            ...(mediaRecord.metadata as object || {}),\r\n            error: 'Cancelled by user',\r\n            cancelled_at: new Date().toISOString()\r\n          }\r\n        })\r\n        .eq('id', mediaId);\r\n\r\n      if (updateError) {\r\n        console.error('[Action] Error updating cancelled status:', updateError);\r\n        return { success: false, error: 'Failed to cancel generation' };\r\n      }\r\n\r\n      revalidatePath('/dashboard');\r\n      return { success: true };\r\n    }\r\n\r\n    // Call Pixio API to cancel the run using the client\r\n    console.log(`[Action] Calling Pixio API to cancel run: ${runId}`);\r\n    \r\n    const apiKey = process.env.PIXIO_DEPLOY_API_KEY;\r\n    if (!apiKey) {\r\n      return { success: false, error: 'API key not configured' };\r\n    }\r\n\r\n    const cancelResult = await cancelPixioRun(runId, apiKey);\r\n\r\n    // Note: Even if the cancel API call fails, we still mark it as cancelled locally\r\n    if (!cancelResult.success) {\r\n      console.warn(`[Action] Pixio cancel API failed: ${cancelResult.error}, but continuing with local cancellation`);\r\n    }\r\n\r\n    // Update database to cancelled/failed status\r\n    const { error: updateError } = await supabaseAdmin\r\n      .from('generated_media')\r\n      .update({\r\n        status: 'failed',\r\n        metadata: {\r\n          ...(mediaRecord.metadata as object || {}),\r\n          error: 'Cancelled by user',\r\n          cancelled_at: new Date().toISOString(),\r\n          cancel_api_status: cancelResult.success ? 'success' : 'failed'\r\n        }\r\n      })\r\n      .eq('id', mediaId);\r\n\r\n    if (updateError) {\r\n      console.error('[Action] Error updating cancelled status:', updateError);\r\n      return { success: false, error: 'Failed to update cancellation status' };\r\n    }\r\n\r\n    console.log(`[Action] Successfully cancelled generation ${mediaId}`);\r\n    revalidatePath('/dashboard');\r\n    return { success: true };\r\n\r\n  } catch (error: any) {\r\n    console.error(`[Action] Error cancelling generation ${mediaId}:`, error);\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Deletes a media item record and its associated file from storage.\r\n */\r\nexport async function deleteMedia(mediaId: string, storagePath: string | null): Promise<{\r\n    success: boolean;\r\n    error?: string;\r\n  }> {\r\n    if (!mediaId) { return { success: false, error: \"Media ID is required.\" }; }\r\n    const supabase = await createClient(); // Use server client to get user\r\n    const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n    if (!user || userError) { return { success: false, error: 'Authentication error' }; }\r\n\r\n    console.log(`[Action] Deleting media ${mediaId} (path: ${storagePath || 'N/A'}) for user ${user.id}`);\r\n    try {\r\n      // Verify ownership using admin client\r\n      const { data: mediaRecord, error: fetchError } = await supabaseAdmin\r\n        .from('generated_media').select('id, user_id, storage_path').eq('id', mediaId).single();\r\n      if (fetchError || !mediaRecord) { console.error(`[Action] Error fetching media ${mediaId} for deletion or not found:`, fetchError); return { success: false, error: 'Media record not found.' }; }\r\n      if (mediaRecord.user_id !== user.id) { console.warn(`[Action] User ${user.id} attempted to delete media ${mediaId} owned by ${mediaRecord.user_id}. Denying.`); return { success: false, error: 'Permission denied.' }; }\r\n\r\n      const actualStoragePath = mediaRecord.storage_path;\r\n\r\n      // Delete from Storage *only if path exists* using the service function\r\n      if (actualStoragePath) {\r\n        console.log(`[Action] Calling service to delete file from storage: ${actualStoragePath}`);\r\n        const { success: deleteSuccess, error: deleteError } = await deleteFileService(actualStoragePath); // Use storage service\r\n        if (!deleteSuccess) { console.error(`[Action] Error deleting file ${actualStoragePath} from storage (continuing):`, deleteError); }\r\n        else { console.log(`[Action] Successfully deleted file ${actualStoragePath} via service.`); }\r\n      } else { console.log(`[Action] No storage path for media ${mediaId}, skipping storage deletion.`); }\r\n\r\n      // Delete from Database using admin client\r\n      console.log(`[Action] Deleting record from database: ${mediaId}`);\r\n      const { error: dbError } = await supabaseAdmin.from('generated_media').delete().eq('id', mediaId);\r\n      if (dbError) { console.error(`[Action] Error deleting record ${mediaId} from database:`, dbError); throw new Error(`Database deletion failed: ${dbError.message}`); }\r\n      console.log(`[Action] Successfully deleted record ${mediaId} from database.`);\r\n\r\n      revalidatePath('/dashboard');\r\n      return { success: true };\r\n    } catch (error: any) {\r\n      console.error(`[Action] Unexpected error during media deletion for ${mediaId}:`, error);\r\n      return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n/**\r\n * Fetches completed and processing media items for the current user.\r\n */\r\nexport async function fetchUserMedia(): Promise<{\r\n  success: boolean;\r\n  media: GeneratedMedia[];\r\n  error?: string;\r\n}> {\r\n  const supabase = await createClient(); // Uses server client\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n  if (!user || userError) { return { success: false, error: 'Authentication error', media: [] }; }\r\n\r\n  try {\r\n    // Use user-context client for RLS\r\n    const { data, error } = await supabase\r\n      .from('generated_media')\r\n      .select('*')\r\n      .eq('user_id', user.id)\r\n      .in('status', ['pending', 'processing', 'completed', 'failed'])\r\n      .order('created_at', { ascending: false })\r\n      .limit(50); // Adjust limit as needed\r\n\r\n    if (error) { throw new Error(`Failed to fetch media: ${error.message}`); }\r\n    return { success: true, media: data || [], error: undefined };\r\n  } catch (error: any) {\r\n    console.error('[Action] Error fetching user media:', error);\r\n    return { success: false, error: error.message, media: [] };\r\n  }\r\n}\r\n\r\n/**\r\n * Server Action to list user's generated images and input images for selection.\r\n */\r\nexport async function listUserImagesForSelection(): Promise<{\r\n    success: boolean;\r\n    images: { value: string; label: string; type: 'generated' | 'input' }[];\r\n    error?: string;\r\n}> {\r\n    const supabase = await createClient(); // Use server client to get user\r\n    const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n    if (!user || userError) { return { success: false, images: [], error: 'Authentication error' }; }\r\n\r\n    try {\r\n        const [generatedResult, inputResult] = await Promise.all([\r\n            // Fetch completed generated images using RLS-enabled client\r\n            supabase\r\n                .from('generated_media')\r\n                .select('id, prompt, media_url')\r\n                .eq('user_id', user.id)\r\n                .eq('media_type', 'image')\r\n                .eq('status', 'completed')\r\n                .not('media_url', 'is', null)\r\n                .order('created_at', { ascending: false })\r\n                .limit(50), // Limit generated images shown\r\n            // Fetch input images using the service function (uses admin client)\r\n            listUserFilesService(user.id, 'inputs')\r\n        ]);\r\n\r\n        const fetchedImages: { value: string; label: string; type: 'generated' | 'input' }[] = [];\r\n\r\n        // Process generated images\r\n        if (generatedResult.error) { console.error(\"[Action] Error fetching generated images:\", generatedResult.error); }\r\n        else if (generatedResult.data) { generatedResult.data.forEach(item => { fetchedImages.push({ value: item.media_url!, label: item.prompt ? `Gen: ${item.prompt.substring(0, 30)}...` : `Generated Image ${item.id.substring(0, 6)}`, type: 'generated', }); }); }\r\n\r\n        // Process input images\r\n        if (!inputResult.success) { console.error(\"[Action] Error fetching input images:\", inputResult.error); }\r\n        else if (inputResult.files) { inputResult.files.forEach(file => { if (file.publicUrl && /\\.(jpg|jpeg|png|webp|gif)$/i.test(file.name)) { fetchedImages.push({ value: file.publicUrl, label: `Input: ${file.name}`, type: 'input', }); } }); }\r\n\r\n        fetchedImages.sort((a, b) => a.label.localeCompare(b.label));\r\n        return { success: true, images: fetchedImages };\r\n\r\n    } catch (error: any) {\r\n        console.error('[Action] Error listing user images:', error);\r\n        return { success: false, images: [], error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;IAmRsB,mBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 1752, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/components/dashboard/media-library.tsx"],"sourcesContent":["// src/components/dashboard/media-library.tsx\r\n'use client';\r\n\r\nimport { useState, useEffect, useCallback, useRef } from 'react'; // Added useRef\r\nimport { fetchUserMedia, deleteMedia, cancelGeneration } from '@/lib/actions/media.actions';\r\nimport { Tabs, TabsList, TabsTrigger } from '@repo/ui';\r\nimport { Card, CardContent } from '@repo/ui';\r\nimport { ImageIcon, VideoIcon, Loader2, Calendar, Download, Copy, Check, AlertCircle, Trash2, Library, Film, XCircle } from 'lucide-react';\r\nimport Image from 'next/image';\r\nimport { toast } from 'sonner';\r\nimport { GeneratedMedia } from '@/types/db_types';\r\nimport { MediaType } from '@/lib/constants/media';\r\nimport { Button } from '@repo/ui';\r\nimport { createClient } from '@repo/supabase/client';\r\nimport { RealtimeChannel } from '@supabase/supabase-js';\r\nimport {\r\n  AlertDialog,\r\n  AlertDialogAction,\r\n  AlertDialogCancel,\r\n  AlertDialogContent,\r\n  AlertDialogDescription,\r\n  AlertDialogFooter,\r\n  AlertDialogHeader,\r\n  AlertDialogTitle,\r\n  AlertDialogTrigger,\r\n} from \"@repo/ui\";\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\n\r\ninterface MediaLibraryProps {\r\n  initialMedia?: GeneratedMedia[];\r\n}\r\n\r\nexport function MediaLibrary({ initialMedia = [] }: MediaLibraryProps) {\r\n  const [media, setMedia] = useState<GeneratedMedia[]>(initialMedia);\r\n  const [activeTab, setActiveTab] = useState<'all' | MediaType>('all');\r\n  const supabase = createClient();\r\n  const [userId, setUserId] = useState<string | null>(null);\r\n  const channelRef = useRef<RealtimeChannel | null>(null);\r\n\r\n  // Get user ID on mount\r\n  useEffect(() => {\r\n    const getUser = async () => {\r\n      const { data: { user } } = await supabase.auth.getUser();\r\n      setUserId(user?.id || null);\r\n    };\r\n    getUser();\r\n  }, [supabase]);\r\n\r\n  useEffect(() => {\r\n    if (!userId || channelRef.current) return; // Don't subscribe if no user or already subscribed\r\n\r\n    console.log(`MediaLibrary: Setting up Realtime for user ${userId}`);\r\n    const channel = supabase\r\n      .channel(`media-updates-for-${userId}`)\r\n      .on<GeneratedMedia>(\r\n        'postgres_changes',\r\n        { event: '*', schema: 'public', table: 'generated_media', filter: `user_id=eq.${userId}` },\r\n        (payload) => {\r\n          console.log('MediaLibrary: Realtime payload:', payload);\r\n          const newMedia = payload.new as GeneratedMedia;\r\n          const oldMedia = payload.old as GeneratedMedia & { id: string };\r\n          setMedia((currentMedia) => {\r\n            let updatedMedia = [...currentMedia];\r\n            if (payload.eventType === 'INSERT') {\r\n              if (!updatedMedia.some(item => item.id === newMedia.id)) {\r\n                updatedMedia.unshift(newMedia); // Add to beginning\r\n                console.log(`MediaLibrary: Inserted ${newMedia.id}`);\r\n              }\r\n            } else if (payload.eventType === 'UPDATE') {\r\n              const index = updatedMedia.findIndex(item => item.id === newMedia.id);\r\n              if (index !== -1) {\r\n                updatedMedia[index] = newMedia;\r\n                console.log(`MediaLibrary: Updated ${newMedia.id}`);\r\n              } else {\r\n                 updatedMedia.unshift(newMedia); // Insert if not found (edge case)\r\n                 console.log(`MediaLibrary: Inserted updated ${newMedia.id}`);\r\n              }\r\n            } else if (payload.eventType === 'DELETE' && oldMedia?.id) {\r\n              updatedMedia = updatedMedia.filter(item => item.id !== oldMedia.id);\r\n              console.log(`MediaLibrary: Deleted ${oldMedia.id}`);\r\n            }\r\n            // Ensure sorting remains consistent\r\n            return updatedMedia.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());\r\n          });\r\n        }\r\n      )\r\n      .subscribe((status, err) => {\r\n        // --- MODIFIED ERROR HANDLING ---\r\n        if (status === 'SUBSCRIBED') {\r\n          console.log(`MediaLibrary: Realtime SUBSCRIBED for user ${userId}`);\r\n        } else if (status === 'CHANNEL_ERROR') {\r\n          // Log more details, specifically handling undefined 'err'\r\n          console.error(`MediaLibrary: Realtime CHANNEL_ERROR. Status: ${status}, Error:`, err ?? 'Error object is undefined');\r\n          toast.error(\"Realtime connection error. Updates might be delayed.\", { duration: 10000 });\r\n        } else if (status === 'TIMED_OUT') {\r\n          console.warn(`MediaLibrary: Realtime TIMED_OUT. Status: ${status}`);\r\n          toast.warning(\"Realtime connection timed out. Attempting to reconnect.\", { duration: 10000 });\r\n        } else if (status === 'CLOSED') {\r\n           console.log(`MediaLibrary: Realtime channel CLOSED for user ${userId}. Status: ${status}`);\r\n           // Optionally attempt to resubscribe or notify user if closure was unexpected\r\n        } else {\r\n          // Log any other status updates\r\n           console.log(`MediaLibrary: Realtime status update: ${status}`);\r\n        }\r\n        // --- END MODIFIED ERROR HANDLING ---\r\n      });\r\n\r\n    channelRef.current = channel; // Store channel in ref\r\n\r\n    // Cleanup function\r\n    return () => {\r\n      if (channelRef.current) {\r\n        console.log(`MediaLibrary: Unsubscribing from Realtime for ${userId}`);\r\n        supabase.removeChannel(channelRef.current).catch(err => console.error(\"Error removing channel:\", err));\r\n        channelRef.current = null; // Clear ref on cleanup\r\n      }\r\n    };\r\n  }, [supabase, userId]); // Depend only on supabase and userId\r\n\r\n  const handleItemDeleted = useCallback((deletedMediaId: string) => {\r\n    setMedia((prevMedia) => prevMedia.filter(item => item.id !== deletedMediaId));\r\n    toast.info(\"Media removed.\");\r\n  }, []);\r\n\r\n  const filteredMedia = activeTab === 'all'\r\n    ? media\r\n    : media.filter(item => item.media_type === activeTab);\r\n\r\n  return (\r\n    <div className=\"mt-10 space-y-6\">\r\n      <div className=\"flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4\">\r\n        <h2 className=\"text-2xl font-semibold flex items-center gap-2\">\r\n          <Library className=\"w-6 h-6 text-primary/80\" /> Media Library\r\n        </h2>\r\n        <Tabs value={activeTab} onValueChange={(value) => setActiveTab(value as 'all' | MediaType)} className=\"w-full sm:w-auto\">\r\n          <TabsList className=\"grid w-full grid-cols-3 bg-white/5 border border-white/10 p-1 rounded-lg backdrop-blur-sm\">\r\n             <TabsTrigger value=\"all\" className=\"data-[state=active]:bg-white/10 data-[state=active]:text-foreground data-[state=active]:shadow-md rounded-md transition-all\">All</TabsTrigger>\r\n             <TabsTrigger value=\"image\" className=\"data-[state=active]:bg-white/10 data-[state=active]:text-foreground data-[state=active]:shadow-md rounded-md transition-all\">Images</TabsTrigger>\r\n             <TabsTrigger value=\"video\" className=\"data-[state=active]:bg-white/10 data-[state=active]:text-foreground data-[state=active]:shadow-md rounded-md transition-all\">Videos</TabsTrigger>\r\n          </TabsList>\r\n        </Tabs>\r\n      </div>\r\n\r\n      <AnimatePresence>\r\n          {filteredMedia.length === 0 ? (\r\n            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -10 }} transition={{ duration: 0.3 }}>\r\n              <Card className=\"glass-card border-dashed border-white/20\">\r\n                <CardContent className=\"flex flex-col items-center justify-center py-20 text-center px-6\">\r\n                  {/* Icon */}\r\n                  <div className=\"p-6 mb-6 rounded-full bg-gradient-to-br from-primary/20 to-secondary/20 border-2 border-primary/30 shadow-lg\">\r\n                    {activeTab === 'image' ? <ImageIcon className=\"h-12 w-12 text-primary\" /> : activeTab === 'video' ? <Film className=\"h-12 w-12 text-primary\" /> : <Library className=\"h-12 w-12 text-primary\" />}\r\n                  </div>\r\n                  \r\n                  {/* Title */}\r\n                  <h3 className=\"text-2xl font-bold mb-3 text-foreground\">\r\n                    {activeTab === 'all' ? 'Your Media Library is Empty' : `No ${activeTab}s Yet`}\r\n                  </h3>\r\n                  \r\n                  {/* Description */}\r\n                  <p className=\"text-muted-foreground max-w-md mb-6 text-base\">\r\n                    {activeTab === 'all'\r\n                      ? 'Start generating AI-powered images and videos. Your creations will appear here.'\r\n                      : `Generate your first ${activeTab} using one of our AI models above.`\r\n                    }\r\n                  </p>\r\n\r\n                  {/* Features List */}\r\n                  <div className=\"grid grid-cols-1 sm:grid-cols-3 gap-4 max-w-2xl mb-6 text-left\">\r\n                    <div className=\"flex items-start gap-2 text-sm\">\r\n                      <div className=\"w-5 h-5 rounded-full bg-primary/20 flex items-center justify-center flex-shrink-0 mt-0.5\">\r\n                        <ImageIcon className=\"w-3 h-3 text-primary\" />\r\n                      </div>\r\n                      <div>\r\n                        <p className=\"font-medium text-foreground/90\">Krea Flux</p>\r\n                        <p className=\"text-xs text-muted-foreground\">High-quality images</p>\r\n                      </div>\r\n                    </div>\r\n                    \r\n                    <div className=\"flex items-start gap-2 text-sm\">\r\n                      <div className=\"w-5 h-5 rounded-full bg-primary/20 flex items-center justify-center flex-shrink-0 mt-0.5\">\r\n                        <ImageIcon className=\"w-3 h-3 text-primary\" />\r\n                      </div>\r\n                      <div>\r\n                        <p className=\"font-medium text-foreground/90\">Qwen Edit</p>\r\n                        <p className=\"text-xs text-muted-foreground\">AI image editing</p>\r\n                      </div>\r\n                    </div>\r\n                    \r\n                    <div className=\"flex items-start gap-2 text-sm\">\r\n                      <div className=\"w-5 h-5 rounded-full bg-primary/20 flex items-center justify-center flex-shrink-0 mt-0.5\">\r\n                        <Film className=\"w-3 h-3 text-primary\" />\r\n                      </div>\r\n                      <div>\r\n                        <p className=\"font-medium text-foreground/90\">Wan 2.2</p>\r\n                        <p className=\"text-xs text-muted-foreground\">Video transitions</p>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n\r\n                  {/* Call to Action */}\r\n                  <button\r\n                    onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}\r\n                    className=\"glass-button bg-gradient-to-r from-primary to-secondary text-white px-6 py-3 rounded-lg font-medium hover:opacity-90 transition-all shadow-md hover:shadow-lg\"\r\n                  >\r\n                    Start Creating\r\n                  </button>\r\n                </CardContent>\r\n              </Card>\r\n            </motion.div>\r\n          ) : (\r\n            <motion.div layout className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-5\">\r\n              {filteredMedia.map((item, index) => (\r\n                 <motion.div key={item.id} layout initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, scale: 0.9 }} transition={{ duration: 0.3, delay: index * 0.05 }}>\r\n                    <MediaCard item={item} onDeleted={() => handleItemDeleted(item.id)} />\r\n                 </motion.div>\r\n              ))}\r\n            </motion.div>\r\n          )}\r\n      </AnimatePresence>\r\n    </div>\r\n  );\r\n}\r\n\r\n// --- MediaCard Component (Updated) ---\r\ninterface MediaCardProps {\r\n  item: GeneratedMedia;\r\n  onDeleted: () => void;\r\n}\r\n\r\nfunction MediaCard({ item, onDeleted }: MediaCardProps) {\r\n  const [isCopied, setIsCopied] = useState(false);\r\n  const [isDeleting, setIsDeleting] = useState(false);\r\n  const [isCancelling, setIsCancelling] = useState(false);\r\n  const formattedDate = new Date(item.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });\r\n\r\n  const downloadMedia = async (e: React.MouseEvent) => {\r\n    e.stopPropagation();\r\n    if (!item.media_url) { toast.error(\"Media URL not available.\"); return; }\r\n    toast.info(\"Starting download...\");\r\n    try {\r\n      const response = await fetch(item.media_url, { mode: 'cors' });\r\n      if (!response.ok) throw new Error(`Fetch failed: ${response.statusText}`);\r\n      const blob = await response.blob();\r\n      const url = window.URL.createObjectURL(blob);\r\n      const a = document.createElement('a');\r\n      a.style.display = 'none'; a.href = url;\r\n      // Determine extension based on URL or media_type\r\n      const urlExtension = item.media_url.split('.').pop()?.toLowerCase();\r\n      const defaultExtension = item.media_type === 'image' ? 'png' : 'mp4'; // Default to mp4 for video\r\n      const extension = urlExtension && ['png', 'jpg', 'jpeg', 'webp', 'gif', 'mp4'].includes(urlExtension) ? `.${urlExtension}` : `.${defaultExtension}`;\r\n      a.download = `${item.media_type}-${item.id.substring(0, 8)}${extension}`;\r\n      document.body.appendChild(a); a.click();\r\n      window.URL.revokeObjectURL(url); document.body.removeChild(a);\r\n      toast.success(`${item.media_type} downloaded`);\r\n    } catch (error: any) { console.error('Download failed:', error); toast.error(`Download failed: ${error.message}`); }\r\n  };\r\n\r\n  const copyPrompt = (e: React.MouseEvent) => {\r\n    e.stopPropagation();\r\n    if (!item.prompt) { toast.error(\"No prompt available.\"); return; }\r\n    navigator.clipboard.writeText(item.prompt).then(() => {\r\n        setIsCopied(true); toast.success('Prompt copied!'); setTimeout(() => setIsCopied(false), 2000);\r\n    }).catch((error) => { console.error('Copy failed:', error); toast.error('Failed to copy prompt'); });\r\n  };\r\n\r\n  const handleDeleteConfirm = async () => {\r\n    if (!item.id) { toast.error(\"Cannot delete: Missing ID.\"); return; }\r\n    setIsDeleting(true);\r\n    console.log(`Deleting media: ${item.id}, path: ${item.storage_path || 'N/A'}`);\r\n    try {\r\n      const result = await deleteMedia(item.id, item.storage_path);\r\n      if (result.success) onDeleted(); // Parent handles UI update and success toast\r\n      else { toast.error(`Delete failed: ${result.error}`); setIsDeleting(false); }\r\n    } catch (error: any) { toast.error(`Error deleting: ${error.message}`); setIsDeleting(false); }\r\n  };\r\n\r\n  const handleCancelConfirm = async () => {\r\n    if (!item.id) { toast.error(\"Cannot cancel: Missing ID.\"); return; }\r\n    setIsCancelling(true);\r\n    console.log(`Cancelling media generation: ${item.id}`);\r\n    try {\r\n      const result = await cancelGeneration(item.id);\r\n      if (result.success) {\r\n        toast.success('Generation cancelled');\r\n        // No need to call onDeleted - Realtime will update the UI\r\n      } else {\r\n        toast.error(`Cancel failed: ${result.error}`);\r\n      }\r\n    } catch (error: any) {\r\n      toast.error(`Error cancelling: ${error.message}`);\r\n    } finally {\r\n      setIsCancelling(false);\r\n    }\r\n  };\r\n\r\n  const isLoading = item.status === 'pending' || item.status === 'processing';\r\n  const isFailed = item.status === 'failed';\r\n  const isCompleted = item.status === 'completed';\r\n  const showActions = isCompleted || isFailed;\r\n  const showCancel = isLoading && !isCancelling;\r\n  const isMp4Video = item.media_type === 'video' && item.media_url?.toLowerCase().endsWith('.mp4');\r\n\r\n  return (\r\n    <motion.div\r\n        whileHover={{ y: -5, scale: 1.03 }}\r\n        transition={{ type: \"spring\", stiffness: 300, damping: 20 }}\r\n        className={`glass-card group relative overflow-hidden rounded-lg border border-white/10 shadow-md transition-all duration-300 flex flex-col h-full ${isLoading ? 'opacity-60 animate-pulse' : ''} ${isFailed ? 'border-destructive/50' : ''}`}\r\n    >\r\n      {/* Media Area */}\r\n      <div className=\"relative aspect-square overflow-hidden bg-black/10\">\r\n        {/* Status Overlays */}\r\n        <AnimatePresence>\r\n          {isLoading && ( <motion.div key=\"loading-overlay\" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} className=\"absolute inset-0 flex flex-col items-center justify-center bg-black/50 backdrop-blur-sm z-10 p-4 text-center\"> <Loader2 className=\"h-8 w-8 animate-spin text-primary mb-2\" /> <span className=\"text-xs font-medium text-primary-foreground\">{item.status}...</span> </motion.div> )}\r\n          {isFailed && ( <motion.div key=\"failed-overlay\" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} className=\"absolute inset-0 flex flex-col items-center justify-center bg-destructive/40 backdrop-blur-sm z-10 p-4 text-center\"> <AlertCircle className=\"h-8 w-8 text-destructive-foreground mb-2\" /> <span className=\"text-xs font-medium text-destructive-foreground\">Failed</span> {typeof item.metadata === 'object' && item.metadata !== null && 'error' in item.metadata && ( <p className=\"text-[10px] text-destructive-foreground/80 mt-1 line-clamp-2\" title={String(item.metadata.error)}> {String(item.metadata.error)} </p> )} </motion.div> )}\r\n        </AnimatePresence>\r\n\r\n        {/* Media display */}\r\n        {isCompleted && item.media_url ? (\r\n            isMp4Video ? (\r\n                <video\r\n                    src={item.media_url}\r\n                    controls\r\n                    preload=\"metadata\"\r\n                    className=\"w-full h-full object-contain transition-transform duration-300 group-hover:scale-105\"\r\n                    onError={(e) => { e.currentTarget.style.display = 'none'; }} // Hide video element on error\r\n                />\r\n            ) : item.media_type === 'video' ? (\r\n                 // Assume webp video if not mp4\r\n                 <Image src={item.media_url} alt={item.prompt || 'Generated video'} fill className=\"object-contain transition-transform duration-300 group-hover:scale-105\" unoptimized={true} onError={(e) => { e.currentTarget.style.display = 'none'; }} />\r\n            ) : (\r\n                 // Image\r\n                 <Image src={item.media_url} alt={item.prompt || 'Generated image'} fill className=\"object-cover transition-transform duration-300 group-hover:scale-105\" unoptimized={true} onError={(e) => { e.currentTarget.style.display = 'none'; }} />\r\n            )\r\n        ) : (\r\n          !isFailed && !isLoading && ( <div className=\"w-full h-full flex items-center justify-center text-muted-foreground/30\"> {item.media_type === 'image' ? <ImageIcon className=\"h-16 w-16\" /> : <VideoIcon className=\"h-16 w-16\" />} </div> )\r\n        )}\r\n\r\n         {/* Media type badge */}\r\n         <div className=\"absolute top-2 right-2 bg-black/50 backdrop-blur-sm rounded-md px-2 py-1 text-xs font-medium flex items-center gap-1 z-20 text-white/90 border border-white/10\">\r\n           {item.media_type === 'image' ? <ImageIcon className=\"h-3 w-3\" /> : <VideoIcon className=\"h-3 w-3\" />}\r\n           <span className=\"capitalize\">{item.media_type}</span>\r\n         </div>\r\n      </div>\r\n\r\n      {/* Content Area */}\r\n      <CardContent className=\"p-3 flex flex-col flex-grow\">\r\n        <p className=\"text-xs text-muted-foreground line-clamp-2 h-8 flex-grow mb-2\" title={item.prompt}> {item.prompt || 'No prompt'} </p>\r\n        <div className=\"flex items-center justify-between mt-auto border-t border-white/10 pt-2\">\r\n          <div className=\"flex items-center gap-1 text-xs text-muted-foreground\"> <Calendar className=\"h-3 w-3\" /> <span>{formattedDate}</span> </div>\r\n          <AnimatePresence>\r\n            {showCancel && (\r\n              <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} className=\"flex gap-1\">\r\n                <AlertDialog>\r\n                  <AlertDialogTrigger asChild>\r\n                    <Button size=\"icon\" variant=\"ghost\" className=\"h-6 w-6 text-orange-500/70 hover:text-orange-500 hover:bg-orange-500/10\" title=\"Cancel generation\" disabled={isCancelling}> {isCancelling ? <Loader2 className=\"h-3.5 w-3.5 animate-spin\" /> : <XCircle className=\"h-3.5 w-3.5\" />} </Button>\r\n                  </AlertDialogTrigger>\r\n                  <AlertDialogContent className=\"glass-card border-orange-500/30\">\r\n                    <AlertDialogHeader> <AlertDialogTitle>Cancel Generation?</AlertDialogTitle> <AlertDialogDescription> This will stop the generation process. Credits will not be refunded. </AlertDialogDescription> </AlertDialogHeader>\r\n                    <AlertDialogFooter> <AlertDialogCancel disabled={isCancelling}>Keep Running</AlertDialogCancel> <AlertDialogAction onClick={handleCancelConfirm} disabled={isCancelling} className=\"bg-orange-500 text-white hover:bg-orange-600\"> {isCancelling ? \"Cancelling...\" : \"Cancel Generation\"} </AlertDialogAction> </AlertDialogFooter>\r\n                  </AlertDialogContent>\r\n                </AlertDialog>\r\n              </motion.div>\r\n            )}\r\n            {showActions && (\r\n              <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} className=\"flex gap-1\">\r\n                {isCompleted && item.media_url && ( <Button size=\"icon\" variant=\"ghost\" className=\"h-6 w-6 text-muted-foreground hover:text-primary\" onClick={downloadMedia} title=\"Download\" disabled={isDeleting}> <Download className=\"h-3.5 w-3.5\" /> </Button> )}\r\n                {item.prompt && ( <Button size=\"icon\" variant=\"ghost\" className=\"h-6 w-6 text-muted-foreground hover:text-primary\" onClick={copyPrompt} title=\"Copy prompt\" disabled={isDeleting}> {isCopied ? <Check className=\"h-3.5 w-3.5 text-green-500\" /> : <Copy className=\"h-3.5 w-3.5\" />} </Button> )}\r\n                <AlertDialog>\r\n                  <AlertDialogTrigger asChild>\r\n                    <Button size=\"icon\" variant=\"ghost\" className=\"h-6 w-6 text-destructive/70 hover:text-destructive hover:bg-destructive/10\" title=\"Delete\" disabled={isDeleting}> {isDeleting ? <Loader2 className=\"h-3.5 w-3.5 animate-spin\" /> : <Trash2 className=\"h-3.5 w-3.5\" />} </Button>\r\n                  </AlertDialogTrigger>\r\n                  <AlertDialogContent className=\"glass-card border-destructive/30\">\r\n                    <AlertDialogHeader> <AlertDialogTitle>Delete Media?</AlertDialogTitle> <AlertDialogDescription> This action cannot be undone. The media record and file will be permanently deleted. </AlertDialogDescription> </AlertDialogHeader>\r\n                    <AlertDialogFooter> <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel> <AlertDialogAction onClick={handleDeleteConfirm} disabled={isDeleting} className=\"bg-destructive text-destructive-foreground hover:bg-destructive/90\"> {isDeleting ? \"Deleting...\" : \"Delete\"} </AlertDialogAction> </AlertDialogFooter>\r\n                  </AlertDialogContent>\r\n                </AlertDialog>\r\n              </motion.div>\r\n            )}\r\n          </AnimatePresence>\r\n        </div>\r\n      </CardContent>\r\n    </motion.div>\r\n  );\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}