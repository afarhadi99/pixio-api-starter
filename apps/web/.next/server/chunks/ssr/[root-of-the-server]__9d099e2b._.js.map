{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/packages/supabase/src/lib/server.ts"],"sourcesContent":["// src/lib/supabase/server.ts\r\nimport { createServerClient, type CookieOptions } from '@supabase/ssr';\r\nimport { cookies } from 'next/headers';\r\nimport { Database } from '@/types/db_types';\r\n\r\nexport async function createClient() {\r\n  const cookieStore = await cookies();\r\n  \r\n  return createServerClient<Database>(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() { \r\n          return cookieStore.getAll();\r\n        },\r\n        setAll(cookiesToSet) {\r\n          try { \r\n            cookiesToSet.forEach(({ name, value, options }) => \r\n              cookieStore.set(name, value, options)\r\n            ); \r\n          } catch { \r\n            // This will happen if we're inside a Server Component\r\n            // This can be ignored if middleware is refreshing sessions\r\n          }\r\n        },\r\n      },\r\n    }\r\n  );\r\n}\r\n"],"names":[],"mappings":"AAAA,6BAA6B;;;;AAC7B;AAAA;AACA;;;AAGO,eAAe;IACpB,MAAM,cAAc,MAAM,CAAA,GAAA,+HAAA,CAAA,UAAO,AAAD;IAEhC,OAAO,CAAA,GAAA,yKAAA,CAAA,qBAAkB,AAAD,sUAGtB;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;gBAEjC,EAAE,OAAM;gBACN,sDAAsD;gBACtD,2DAA2D;gBAC7D;YACF;QACF;IACF;AAEJ","debugId":null}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/lib/validators/auth.ts"],"sourcesContent":["// src/lib/validators/auth.ts\r\nimport { z } from 'zod';\r\n\r\nexport const loginSchema = z.object({\r\n  email: z.string().email({ message: 'Please enter a valid email address' }),\r\n  password: z.string().min(1, { message: 'Password is required' }),\r\n});\r\n\r\nexport const signupSchema = z.object({\r\n  email: z.string().email({ message: 'Please enter a valid email address' }),\r\n  password: z.string().min(8, { message: 'Password must be at least 8 characters' }),\r\n  full_name: z.string().min(1, { message: 'Name is required' }).optional(),\r\n});\r\n\r\nexport const updateProfileSchema = z.object({\r\n  full_name: z.string().min(1, { message: 'Name is required' }),\r\n  avatar_url: z.string().optional(),\r\n});\r\n\r\nexport type TLoginSchema = z.infer<typeof loginSchema>;\r\nexport type TSignupSchema = z.infer<typeof signupSchema>;\r\nexport type TUpdateProfileSchema = z.infer<typeof updateProfileSchema>;\r\n"],"names":[],"mappings":"AAAA,6BAA6B;;;;;;AAC7B;;AAEO,MAAM,cAAc,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAClC,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,KAAK,CAAC;QAAE,SAAS;IAAqC;IACxE,UAAU,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAuB;AAChE;AAEO,MAAM,eAAe,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACnC,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,KAAK,CAAC;QAAE,SAAS;IAAqC;IACxE,UAAU,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAyC;IAChF,WAAW,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmB,GAAG,QAAQ;AACxE;AAEO,MAAM,sBAAsB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1C,WAAW,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAAmB;IAC3D,YAAY,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;AACjC","debugId":null}},
    {"offset": {"line": 119, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/lib/config/pricing.ts"],"sourcesContent":["// src/lib/config/pricing.ts\r\nexport interface PricingTier {\r\n  id: 'free' | 'pro' | 'business';\r\n  name: string;\r\n  description: string;\r\n  features: string[];\r\n  popular: boolean;\r\n  credits: number; // Added credits field\r\n  // Each tier can have monthly and yearly pricing options\r\n  pricing: {\r\n    monthly: {\r\n      priceId: string | null; // Stripe Price ID\r\n      amount: number | null;  // Amount in cents\r\n    };\r\n    yearly: {\r\n      priceId: string | null; // Stripe Price ID\r\n      amount: number | null;  // Amount in cents\r\n      discount?: number;      // Optional percentage discount compared to monthly\r\n    };\r\n  };\r\n}\r\n\r\n// Read price IDs from environment variables\r\nexport const STRIPE_PRICE_IDS = {\r\n  PRO_MONTHLY: process.env.NEXT_PUBLIC_STRIPE_PRICE_PRO_MONTHLY || '',\r\n  PRO_YEARLY: process.env.NEXT_PUBLIC_STRIPE_PRICE_PRO_YEARLY || '',\r\n  BUSINESS_MONTHLY: process.env.NEXT_PUBLIC_STRIPE_PRICE_BUSINESS_MONTHLY || '',\r\n  BUSINESS_YEARLY: process.env.NEXT_PUBLIC_STRIPE_PRICE_BUSINESS_YEARLY || '',\r\n  // Credit pack price IDs\r\n  CREDIT_PACK_1000: process.env.NEXT_PUBLIC_STRIPE_PRICE_CREDIT_PACK_1000 || '',\r\n  CREDIT_PACK_2500: process.env.NEXT_PUBLIC_STRIPE_PRICE_CREDIT_PACK_2500 || '',\r\n  CREDIT_PACK_5000: process.env.NEXT_PUBLIC_STRIPE_PRICE_CREDIT_PACK_5000 || '',\r\n};\r\n\r\n// Define credit packs for purchase\r\nexport const CREDIT_PACKS = [\r\n  {\r\n    id: 'credits-1000',\r\n    name: '1000 Credits',\r\n    description: 'Top up with a small credit pack',\r\n    amount: 1000,\r\n    price: 1000, // $10 in cents\r\n    priceId: STRIPE_PRICE_IDS.CREDIT_PACK_1000,\r\n  },\r\n  {\r\n    id: 'credits-2500',\r\n    name: '2500 Credits',\r\n    description: 'Best value for regular users',\r\n    amount: 2500,\r\n    price: 2500, // $25 in cents\r\n    priceId: STRIPE_PRICE_IDS.CREDIT_PACK_2500,\r\n  },\r\n  {\r\n    id: 'credits-5000',\r\n    name: '5000 Credits',\r\n    description: 'Best value for power users',\r\n    amount: 5000,\r\n    price: 5000, // $50 in cents\r\n    priceId: STRIPE_PRICE_IDS.CREDIT_PACK_5000,\r\n  }\r\n];\r\n\r\n// Check if price IDs are configured\r\nconst isPricingConfigured = () => {\r\n  return (\r\n    STRIPE_PRICE_IDS.PRO_MONTHLY &&\r\n    STRIPE_PRICE_IDS.PRO_YEARLY &&\r\n    STRIPE_PRICE_IDS.BUSINESS_MONTHLY &&\r\n    STRIPE_PRICE_IDS.BUSINESS_YEARLY\r\n  );\r\n};\r\n\r\n// Show warning if price IDs are not configured in production\r\nif (process.env.NODE_ENV === 'production' && !isPricingConfigured()) {\r\n  console.warn('Warning: Stripe price IDs are not configured in environment variables.');\r\n}\r\n\r\nexport const PRICING_TIERS: PricingTier[] = [\r\n  {\r\n    id: 'free',\r\n    name: 'Free',\r\n    description: 'Essential features for individuals',\r\n    credits: 500, // 500 credits for free tier\r\n    features: [\r\n      'Basic dashboard access',\r\n      'Limited access to features',\r\n      'Community support',\r\n      '500 credits per month',\r\n    ],\r\n    popular: false,\r\n    pricing: {\r\n      monthly: {\r\n        priceId: null,\r\n        amount: null,\r\n      },\r\n      yearly: {\r\n        priceId: null,\r\n        amount: null,\r\n      },\r\n    },\r\n  },\r\n  {\r\n    id: 'pro',\r\n    name: 'Pro',\r\n    description: 'Perfect for professionals',\r\n    credits: 3000, // 3000 credits for pro tier\r\n    features: [\r\n      'Everything in Free',\r\n      'Advanced features',\r\n      'Priority support',\r\n      'Extended usage limits',\r\n      '3000 credits per month',\r\n    ],\r\n    popular: true,\r\n    pricing: {\r\n      monthly: {\r\n        priceId: STRIPE_PRICE_IDS.PRO_MONTHLY || null,\r\n        amount: 2900, // $29/month\r\n      },\r\n      yearly: {\r\n        priceId: STRIPE_PRICE_IDS.PRO_YEARLY || null,\r\n        amount: 29000, // $290/year\r\n        discount: 16,  // 16% discount compared to monthly\r\n      },\r\n    },\r\n  },\r\n  {\r\n    id: 'business',\r\n    name: 'Business',\r\n    description: 'For teams and organizations',\r\n    credits: 6000, // 6000 credits for business tier\r\n    features: [\r\n      'Everything in Pro',\r\n      'Enterprise features',\r\n      'Dedicated support',\r\n      'Custom integrations',\r\n      'Team management',\r\n      '6000 credits per month',\r\n    ],\r\n    popular: false,\r\n    pricing: {\r\n      monthly: {\r\n        priceId: STRIPE_PRICE_IDS.BUSINESS_MONTHLY || null,\r\n        amount: 5900, // $59/month\r\n      },\r\n      yearly: {\r\n        priceId: STRIPE_PRICE_IDS.BUSINESS_YEARLY || null,\r\n        amount: 59000, // $590/year\r\n        discount: 16,  // 16% discount compared to monthly\r\n      },\r\n    },\r\n  },\r\n];\r\n\r\n// Helper function to get a tier by ID\r\nexport function getTierById(id: string): PricingTier | undefined {\r\n  return PRICING_TIERS.find(tier => tier.id === id);\r\n}\r\n\r\n// Build a mapping of price IDs to tier information for easy lookup\r\nexport type PriceIdInfo = {\r\n  tierId: 'free' | 'pro' | 'business';\r\n  interval: 'monthly' | 'yearly';\r\n};\r\n\r\n// Create a map of price IDs to tier info\r\nexport const PRICE_ID_MAP: Record<string, PriceIdInfo> = {};\r\n\r\n// Populate the price ID map\r\nPRICING_TIERS.forEach(tier => {\r\n  // Add monthly price ID if exists\r\n  if (tier.pricing.monthly.priceId) {\r\n    PRICE_ID_MAP[tier.pricing.monthly.priceId] = {\r\n      tierId: tier.id as 'free' | 'pro' | 'business',\r\n      interval: 'monthly'\r\n    };\r\n  }\r\n\r\n  // Add yearly price ID if exists\r\n  if (tier.pricing.yearly.priceId) {\r\n    PRICE_ID_MAP[tier.pricing.yearly.priceId] = {\r\n      tierId: tier.id as 'free' | 'pro' | 'business',\r\n      interval: 'yearly'\r\n    };\r\n  }\r\n});\r\n\r\n// Helper function to get tier info from a price ID\r\nexport function getTierByPriceId(priceId: string | null | undefined): { \r\n  tier: PricingTier | undefined, \r\n  interval: 'monthly' | 'yearly' | undefined \r\n} {\r\n  if (!priceId) {\r\n    // Default to free tier with no interval\r\n    const freeTier = getTierById('free');\r\n    return { tier: freeTier, interval: undefined };\r\n  }\r\n\r\n  const priceInfo = PRICE_ID_MAP[priceId];\r\n\r\n  if (!priceInfo) {\r\n    // Price ID not found in our configuration\r\n    return { tier: undefined, interval: undefined };\r\n  }\r\n\r\n  const tier = getTierById(priceInfo.tierId);\r\n\r\n  return { \r\n    tier,\r\n    interval: priceInfo.interval\r\n  };\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 330, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/packages/supabase/src/lib/admin.ts"],"sourcesContent":["// src/lib/supabase/admin.ts\r\nimport { createClient } from '@supabase/supabase-js';\r\nimport Stripe from 'stripe';\r\nimport { Database } from '@/types/db_types';\r\nimport { safeToISOString } from '@/lib/utils';\r\nimport { resetSubscriptionCredits } from '@/lib/credits';\r\nimport { getTierByPriceId } from '@/lib/config/pricing';\r\n\r\n// Create a Supabase client with the service role key\r\nexport const supabaseAdmin = createClient<Database>(\r\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n  process.env.SUPABASE_SERVICE_ROLE_KEY!\r\n);\r\n\r\n// Initialize Stripe\r\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\r\n  apiVersion: '2025-03-31.basil',\r\n});\r\n\r\n// Define the Stripe Subscription interface explicitly with the fields we need\r\ninterface StripeSubscription {\r\n  id: string;\r\n  status: string;\r\n  metadata: Record<string, any>;\r\n  items: {\r\n    data: Array<{\r\n      price: { id: string };\r\n      quantity: number;\r\n    }>;\r\n  };\r\n  cancel_at_period_end: boolean;\r\n  cancel_at: number | null;\r\n  canceled_at: number | null;\r\n  current_period_start: number;\r\n  current_period_end: number;\r\n  created: number;\r\n  ended_at: number | null;\r\n  trial_start: number | null;\r\n  trial_end: number | null;\r\n}\r\n\r\n// Create or retrieve a customer from the customers table\r\nexport async function createOrRetrieveCustomer({\r\n  uuid,\r\n  email,\r\n}: {\r\n  uuid: string;\r\n  email: string;\r\n}) {\r\n  const { data: existingCustomer, error: customerError } = await supabaseAdmin\r\n    .from('customers')\r\n    .select('stripe_customer_id')\r\n    .eq('id', uuid)\r\n    .single();\r\n\r\n  if (existingCustomer?.stripe_customer_id) {\r\n    return existingCustomer.stripe_customer_id;\r\n  }\r\n\r\n  // Create a new customer in Stripe\r\n  const customer = await stripe.customers.create({\r\n    email,\r\n    metadata: {\r\n      supabaseUUID: uuid,\r\n    },\r\n  });\r\n\r\n  // Insert the customer into our database\r\n  const { error } = await supabaseAdmin\r\n    .from('customers')\r\n    .insert([{ id: uuid, stripe_customer_id: customer.id }]);\r\n\r\n  if (error) throw error;\r\n\r\n  return customer.id;\r\n}\r\n\r\n// Upsert product record in the database\r\nexport async function upsertProductRecord(product: Stripe.Product) {\r\n  const { error } = await supabaseAdmin\r\n    .from('products')\r\n    .upsert([\r\n      {\r\n        id: product.id,\r\n        active: product.active,\r\n        name: product.name,\r\n        description: product.description ?? null,\r\n        image: product.images?.[0] ?? null,\r\n        metadata: product.metadata,\r\n      },\r\n    ]);\r\n  \r\n  if (error) throw error;\r\n  console.log(`Product inserted/updated: ${product.id}`);\r\n}\r\n\r\n// Delete product record from the database\r\nexport async function deleteProductRecord(productId: string) {\r\n  const { error } = await supabaseAdmin\r\n    .from('products')\r\n    .delete()\r\n    .eq('id', productId);\r\n  \r\n  if (error) throw error;\r\n  console.log(`Product deleted: ${productId}`);\r\n}\r\n\r\n// Upsert price record in the database\r\nexport async function upsertPriceRecord(price: Stripe.Price) {\r\n  // Extract interval details\r\n  const interval = price.recurring?.interval as Database['public']['Enums']['pricing_plan_interval'] | null;\r\n  const intervalCount = price.recurring?.interval_count ?? null;\r\n  \r\n  // Extract price type\r\n  const type = price.type as Database['public']['Enums']['pricing_type'];\r\n  \r\n  const { error } = await supabaseAdmin\r\n    .from('prices')\r\n    .upsert([\r\n      {\r\n        id: price.id,\r\n        product_id: typeof price.product === 'string' ? price.product : '',\r\n        active: price.active,\r\n        currency: price.currency,\r\n        description: price.nickname ?? null,\r\n        type,\r\n        unit_amount: price.unit_amount ?? null,\r\n        interval,\r\n        interval_count: intervalCount,\r\n        trial_period_days: price.recurring?.trial_period_days ?? null,\r\n        metadata: price.metadata,\r\n      },\r\n    ]);\r\n  \r\n  if (error) throw error;\r\n  console.log(`Price inserted/updated: ${price.id}`);\r\n}\r\n\r\n// Delete price record from the database\r\nexport async function deletePriceRecord(priceId: string) {\r\n  const { error } = await supabaseAdmin\r\n    .from('prices')\r\n    .delete()\r\n    .eq('id', priceId);\r\n  \r\n  if (error) throw error;\r\n  console.log(`Price deleted: ${priceId}`);\r\n}\r\n\r\n// Manage subscription status change in the database\r\nexport async function manageSubscriptionStatusChange(\r\n  subscriptionId: string,\r\n  customerId: string,\r\n  createAction = false\r\n) {\r\n  try {\r\n    // Get customer's UUID from mapping table\r\n    const { data: customerData, error: customerError } = await supabaseAdmin\r\n      .from('customers')\r\n      .select('id')\r\n      .eq('stripe_customer_id', customerId)\r\n      .single();\r\n\r\n    if (customerError || !customerData?.id) {\r\n      console.error(`Customer not found: ${customerId}`);\r\n      throw new Error(`Customer not found: ${customerId}`);\r\n    }\r\n    \r\n    const { id: uuid } = customerData;\r\n    \r\n    // Retrieve subscription details from Stripe\r\n    const stripeSubscription = await stripe.subscriptions.retrieve(subscriptionId, {\r\n      expand: ['default_payment_method', 'items.data.price', 'items.data.price.product'],\r\n    });\r\n\r\n    // Handle as plain object to avoid TypeScript issues\r\n    const subscription = stripeSubscription as any;\r\n\r\n    // Get the price and product details from the subscription\r\n    const priceId = subscription.items.data[0].price.id;\r\n    const price = subscription.items.data[0].price;\r\n    const product = subscription.items.data[0].price.product;\r\n    \r\n    // Check if the price exists in our database\r\n    const { data: existingPrice } = await supabaseAdmin\r\n      .from('prices')\r\n      .select('id')\r\n      .eq('id', priceId)\r\n      .maybeSingle();\r\n      \r\n    // If price doesn't exist, insert both the product and price first\r\n    if (!existingPrice) {\r\n      console.log(`Price ${priceId} not found in database. Adding to database first...`);\r\n      \r\n      // First check if the product exists\r\n      const { data: existingProduct } = await supabaseAdmin\r\n        .from('products')\r\n        .select('id')\r\n        .eq('id', product.id)\r\n        .maybeSingle();\r\n        \r\n      // Insert product if it doesn't exist\r\n      if (!existingProduct) {\r\n        console.log(`Product ${product.id} not found. Adding product...`);\r\n        await supabaseAdmin\r\n          .from('products')\r\n          .upsert([{\r\n            id: product.id,\r\n            active: product.active,\r\n            name: product.name,\r\n            description: product.description ?? null,\r\n            image: product.images?.[0] ?? null,\r\n            metadata: product.metadata,\r\n          }]);\r\n      }\r\n      \r\n      // Then insert the price\r\n      console.log(`Adding price ${priceId}...`);\r\n      await supabaseAdmin\r\n        .from('prices')\r\n        .upsert([{\r\n          id: priceId,\r\n          product_id: product.id,\r\n          active: price.active,\r\n          currency: price.currency,\r\n          description: price.nickname ?? null,\r\n          type: price.type,\r\n          unit_amount: price.unit_amount ?? null,\r\n          interval: price.recurring?.interval ?? null,\r\n          interval_count: price.recurring?.interval_count ?? null,\r\n          trial_period_days: price.recurring?.trial_period_days ?? null,\r\n          metadata: price.metadata,\r\n        }]);\r\n    }\r\n    \r\n    // Define helper function inline\r\n    const safeToISOString = (timestamp: number | null | undefined): string | null => {\r\n      if (timestamp === null || timestamp === undefined) return null;\r\n      try {\r\n        return new Date(timestamp * 1000).toISOString();\r\n      } catch (error) {\r\n        console.error(`Invalid timestamp: ${timestamp}`, error);\r\n        return null;\r\n      }\r\n    };\r\n    \r\n    // Current time as fallback\r\n    const now = new Date().toISOString();\r\n    \r\n    // Upsert the subscription in the database\r\n    const subscriptionData = {\r\n      id: subscription.id,\r\n      user_id: uuid,\r\n      status: subscription.status,\r\n      metadata: subscription.metadata,\r\n      price_id: priceId,\r\n      quantity: subscription.items.data[0].quantity,\r\n      cancel_at_period_end: subscription.cancel_at_period_end,\r\n      cancel_at: subscription.cancel_at ? safeToISOString(subscription.cancel_at) : null,\r\n      canceled_at: subscription.canceled_at ? safeToISOString(subscription.canceled_at) : null,\r\n      current_period_start: safeToISOString(subscription.current_period_start) || now,\r\n      current_period_end: safeToISOString(subscription.current_period_end) || now,\r\n      created: safeToISOString(subscription.created) || now,\r\n      ended_at: subscription.ended_at ? safeToISOString(subscription.ended_at) : null,\r\n      trial_start: subscription.trial_start ? safeToISOString(subscription.trial_start) : null,\r\n      trial_end: subscription.trial_end ? safeToISOString(subscription.trial_end) : null,\r\n    };\r\n\r\n    console.log(`Upserting subscription ${subscription.id} for user ${uuid}`);\r\n    \r\n    const { error } = await supabaseAdmin\r\n      .from('subscriptions')\r\n      .upsert([subscriptionData]);\r\n\r\n    if (error) {\r\n      console.error(`Supabase subscription upsert error:`, error);\r\n      throw error;\r\n    }\r\n    console.log(`Subscription ${subscription.id} successfully updated for user ${uuid}`);\r\n\r\n    // After subscription is processed, reset subscription credits based on tier\r\n    if (subscription.status === 'active' || subscription.status === 'trialing') {\r\n      // Get the product details to determine the tier\r\n      const { tier } = getTierByPriceId(priceId);\r\n      \r\n      if (tier) {\r\n        console.log(`Resetting credits for user ${uuid} to tier ${tier.id} level`);\r\n        await resetSubscriptionCredits(uuid, tier.id as 'free' | 'pro' | 'business');\r\n      }\r\n    }\r\n\r\n    return subscription;\r\n  } catch (error) {\r\n    console.error('Error in manageSubscriptionStatusChange:', error);\r\n    throw error;\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 545, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/lib/credits.ts"],"sourcesContent":["// src/lib/credits.ts\r\nimport { createClient } from '@repo/supabase/server';\r\nimport { getSubscriptionTier } from '@repo/supabase/subscriptions';\r\nimport { PRICING_TIERS } from '@/lib/config/pricing';\r\nimport { cache } from 'react';\r\nimport { supabaseAdmin } from '@repo/supabase/admin';\r\n\r\n// Get credits based on subscription tier\r\nexport function getCreditsByTier(tier: 'free' | 'pro' | 'business'): number {\r\n  const tierData = PRICING_TIERS.find(t => t.id === tier);\r\n  return tierData?.credits || 0;\r\n}\r\n\r\n// Get user's total credits (cached)\r\nexport const getUserCredits = cache(async () => {\r\n  const supabase = await createClient();\r\n  \r\n  // Get current user\r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n  if (userError || !user) {\r\n    return { subscriptionCredits: 0, purchasedCredits: 0, total: 0 };\r\n  }\r\n  \r\n  // Fetch user credits\r\n  const { data: userData, error: userDataError } = await supabase\r\n    .from('users')\r\n    .select('subscription_credits, purchased_credits')\r\n    .eq('id', user.id)\r\n    .single();\r\n  \r\n  if (userDataError || !userData) {\r\n    console.error('Error fetching user credits:', userDataError?.message);\r\n    return { subscriptionCredits: 0, purchasedCredits: 0, total: 0 };\r\n  }\r\n  \r\n  const subscriptionCredits = userData.subscription_credits || 0;\r\n  const purchasedCredits = userData.purchased_credits || 0;\r\n  \r\n  return {\r\n    subscriptionCredits,\r\n    purchasedCredits,\r\n    total: subscriptionCredits + purchasedCredits\r\n  };\r\n});\r\n\r\n// Reset subscription credits based on tier\r\nexport async function resetSubscriptionCredits(userId: string, tier: 'free' | 'pro' | 'business') {\r\n  const creditAmount = getCreditsByTier(tier);\r\n  \r\n  console.log(`Resetting subscription credits for user ${userId} to ${creditAmount} (${tier} tier)`);\r\n  \r\n  const { error } = await supabaseAdmin\r\n    .from('users')\r\n    .update({\r\n      subscription_credits: creditAmount,\r\n      last_credits_reset_date: new Date().toISOString()\r\n    })\r\n    .eq('id', userId);\r\n  \r\n  if (error) {\r\n    console.error('Error resetting subscription credits:', error.message);\r\n    return false;\r\n  }\r\n  \r\n  console.log(`Successfully reset credits to ${creditAmount} for user ${userId}`);\r\n  return true;\r\n}\r\n\r\n// Add purchased credits to user account\r\nexport async function addPurchasedCredits(userId: string, amount: number) {\r\n  // Get current purchased credits\r\n  const { data: userData, error: fetchError } = await supabaseAdmin\r\n    .from('users')\r\n    .select('purchased_credits')\r\n    .eq('id', userId)\r\n    .single();\r\n  \r\n  if (fetchError) {\r\n    console.error('Error fetching user data:', fetchError.message);\r\n    return false;\r\n  }\r\n  \r\n  const currentCredits = userData?.purchased_credits || 0;\r\n  const newTotal = currentCredits + amount;\r\n  \r\n  console.log(`Updating user ${userId} from ${currentCredits} to ${newTotal} purchased credits`);\r\n  \r\n  // Update purchased credits\r\n  const { error: updateError } = await supabaseAdmin\r\n    .from('users')\r\n    .update({ purchased_credits: newTotal })\r\n    .eq('id', userId);\r\n  \r\n  if (updateError) {\r\n    console.error('Error updating purchased credits:', updateError.message);\r\n    return false;\r\n  }\r\n  \r\n  console.log(`Successfully updated credits to ${newTotal}`);\r\n  return true;\r\n}\r\n\r\n// Use credits (first use subscription credits, then purchased)\r\nexport async function useCredits(userId: string, amount: number, description: string = '') {\r\n  const supabase = await createClient();\r\n  \r\n  // Get current credits\r\n  const { data: userData, error: fetchError } = await supabase\r\n    .from('users')\r\n    .select('subscription_credits, purchased_credits')\r\n    .eq('id', userId)\r\n    .single();\r\n  \r\n  if (fetchError) {\r\n    console.error('Error fetching user credits:', fetchError.message);\r\n    return false;\r\n  }\r\n  \r\n  const subscriptionCredits = userData?.subscription_credits || 0;\r\n  const purchasedCredits = userData?.purchased_credits || 0;\r\n  \r\n  // Check if user has enough credits\r\n  if (subscriptionCredits + purchasedCredits < amount) {\r\n    return false; // Not enough credits\r\n  }\r\n  \r\n  // Use subscription credits first\r\n  let remainingAmount = amount;\r\n  let newSubscriptionCredits = subscriptionCredits;\r\n  let newPurchasedCredits = purchasedCredits;\r\n  \r\n  if (subscriptionCredits >= remainingAmount) {\r\n    newSubscriptionCredits -= remainingAmount;\r\n    remainingAmount = 0;\r\n  } else {\r\n    remainingAmount -= subscriptionCredits;\r\n    newSubscriptionCredits = 0;\r\n    \r\n    // Use purchased credits for the remainder\r\n    newPurchasedCredits -= remainingAmount;\r\n  }\r\n  \r\n  // Update credits using admin client for more reliable updates\r\n  const { error: updateError } = await supabaseAdmin\r\n    .from('users')\r\n    .update({\r\n      subscription_credits: newSubscriptionCredits,\r\n      purchased_credits: newPurchasedCredits\r\n    })\r\n    .eq('id', userId);\r\n  \r\n  if (updateError) {\r\n    console.error('Error updating credits:', updateError.message);\r\n    return false;\r\n  }\r\n  \r\n  // Record usage\r\n  const { error: usageError } = await supabaseAdmin\r\n    .from('credit_usage')\r\n    .insert({\r\n      user_id: userId,\r\n      amount,\r\n      description\r\n    });\r\n  \r\n  if (usageError) {\r\n    console.error('Error recording credit usage:', usageError.message);\r\n  }\r\n  \r\n  return true;\r\n}\r\n\r\n// Initialize credits for a new user (called when a user first signs up)\r\nexport async function initializeUserCredits(userId: string) {\r\n  // Free tier credits by default\r\n  const initialCredits = getCreditsByTier('free');\r\n  \r\n  console.log(`Initializing credits for new user ${userId} with ${initialCredits} credits`);\r\n  \r\n  const { error } = await supabaseAdmin\r\n    .from('users')\r\n    .update({\r\n      subscription_credits: initialCredits,\r\n      purchased_credits: 0,\r\n      last_credits_reset_date: new Date().toISOString()\r\n    })\r\n    .eq('id', userId);\r\n  \r\n  if (error) {\r\n    console.error('Error initializing user credits:', error.message);\r\n    return false;\r\n  }\r\n  \r\n  console.log(`Successfully initialized ${initialCredits} credits for user ${userId}`);\r\n  return true;\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 699, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/lib/actions/auth.actions.ts"],"sourcesContent":["// src/lib/actions/auth.actions.ts\r\n'use server';\r\n\r\nimport { createClient } from '@repo/supabase/server';\r\nimport { redirect } from 'next/navigation';\r\nimport { cookies } from 'next/headers';\r\nimport { loginSchema, signupSchema, TLoginSchema, TSignupSchema, updateProfileSchema, TUpdateProfileSchema } from '@/lib/validators/auth';\r\nimport { initializeUserCredits } from '@/lib/credits';\r\n\r\nexport async function login(values: TLoginSchema) {\r\n  // Validate input\r\n  const validatedFields = loginSchema.safeParse(values);\r\n  if (!validatedFields.success) {\r\n    return { error: 'Invalid input' };\r\n  }\r\n\r\n  const { email, password } = validatedFields.data;\r\n  \r\n  // Call cookies to prevent caching\r\n  cookies();\r\n\r\n  const supabase = await createClient();\r\n  \r\n  const { error } = await supabase.auth.signInWithPassword({\r\n    email,\r\n    password,\r\n  });\r\n  \r\n  if (error) {\r\n    return { error: error.message };\r\n  }\r\n  \r\n  redirect('/dashboard');\r\n}\r\n\r\nexport async function signup(values: TSignupSchema) {\r\n  // Validate input\r\n  const validatedFields = signupSchema.safeParse(values);\r\n  if (!validatedFields.success) {\r\n    return { error: 'Invalid input' };\r\n  }\r\n\r\n  const { email, password, full_name } = validatedFields.data;\r\n  \r\n  // Call cookies to prevent caching\r\n  cookies();\r\n\r\n  const supabase = await createClient();\r\n  \r\n  const { data, error } = await supabase.auth.signUp({\r\n    email,\r\n    password,\r\n    options: {\r\n      emailRedirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/callback`,\r\n      data: {\r\n        full_name,\r\n      },\r\n    },\r\n  });\r\n  \r\n  if (error) {\r\n    return { error: error.message };\r\n  }\r\n  \r\n  // Initialize credits for the new user\r\n  if (data.user) {\r\n    await initializeUserCredits(data.user.id);\r\n  }\r\n  \r\n  // Check if email confirmation is required\r\n  // Redirect to a confirmation page if needed\r\n  \r\n  redirect('/dashboard');\r\n}\r\n\r\nexport async function logout() {\r\n  const supabase = await createClient();\r\n  await supabase.auth.signOut();\r\n  redirect('/');\r\n}\r\n\r\nexport async function updateProfile(values: TUpdateProfileSchema) {\r\n  // Validate input\r\n  const validatedFields = updateProfileSchema.safeParse(values);\r\n  if (!validatedFields.success) {\r\n    return { error: 'Invalid input' };\r\n  }\r\n\r\n  const { full_name, avatar_url } = validatedFields.data;\r\n  \r\n  // Call cookies to prevent caching\r\n  cookies();\r\n\r\n  const supabase = await createClient();\r\n  \r\n  const { data: { user }, error: userError } = await supabase.auth.getUser();\r\n  \r\n  if (userError || !user) {\r\n    return { error: 'Authentication error' };\r\n  }\r\n  \r\n  // Update user metadata\r\n  const { error: updateAuthError } = await supabase.auth.updateUser({\r\n    data: { full_name, avatar_url },\r\n  });\r\n  \r\n  if (updateAuthError) {\r\n    return { error: updateAuthError.message };\r\n  }\r\n  \r\n  // Update public profile\r\n  const { error: updateProfileError } = await supabase\r\n    .from('users')\r\n    .update({\r\n      full_name,\r\n      avatar_url,\r\n    })\r\n    .eq('id', user.id);\r\n  \r\n  if (updateProfileError) {\r\n    return { error: updateProfileError.message };\r\n  }\r\n  \r\n  return { success: true };\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 846, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/.next-internal/server/app/%28auth%29/login/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {login as '40028f1c67f846ebc4c7ecf11a52cdea7b085264e0'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 904, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/app/%28auth%29/login/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/apps/web/src/app/(auth)/login/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/app/(auth)/login/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA0S,GACvU,wEACA","debugId":null}},
    {"offset": {"line": 918, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/alish/Documents/GitHub/pixio-api-starter/apps/web/src/app/%28auth%29/login/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/apps/web/src/app/(auth)/login/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/app/(auth)/login/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAsR,GACnT,oDACA","debugId":null}},
    {"offset": {"line": 932, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}