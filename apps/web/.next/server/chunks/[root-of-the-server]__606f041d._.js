module.exports = {

"[project]/apps/web/.next-internal/server/app/api/webhooks/pixio/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/punycode [external] (punycode, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[project]/packages/supabase/src/lib/server.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/lib/supabase/server.ts
__turbopack_context__.s({
    "createClient": (()=>createClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/createServerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/headers.js [app-route] (ecmascript)");
;
;
async function createClient() {
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServerClient"])(("TURBOPACK compile-time value", "https://eskcmosgdvrkultpuljo.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVza2Ntb3NnZHZya3VsdHB1bGpvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU4NDQ5MzIsImV4cCI6MjA4MTQyMDkzMn0.WI3zZ7w6XOPA_cxzemInP0EIaQADMbj5kzpFXJtHZGQ"), {
        cookies: {
            getAll () {
                return cookieStore.getAll();
            },
            setAll (cookiesToSet) {
                try {
                    cookiesToSet.forEach(({ name, value, options })=>cookieStore.set(name, value, options));
                } catch  {
                // This will happen if we're inside a Server Component
                // This can be ignored if middleware is refreshing sessions
                }
            }
        }
    });
}
}}),
"[project]/apps/web/src/lib/config/pricing.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/lib/config/pricing.ts
__turbopack_context__.s({
    "CREDIT_PACKS": (()=>CREDIT_PACKS),
    "PRICE_ID_MAP": (()=>PRICE_ID_MAP),
    "PRICING_TIERS": (()=>PRICING_TIERS),
    "STRIPE_PRICE_IDS": (()=>STRIPE_PRICE_IDS),
    "getTierById": (()=>getTierById),
    "getTierByPriceId": (()=>getTierByPriceId)
});
const STRIPE_PRICE_IDS = {
    PRO_MONTHLY: ("TURBOPACK compile-time value", "test") || '',
    PRO_YEARLY: ("TURBOPACK compile-time value", "test") || '',
    BUSINESS_MONTHLY: ("TURBOPACK compile-time value", "test") || '',
    BUSINESS_YEARLY: ("TURBOPACK compile-time value", "test") || '',
    // Credit pack price IDs
    CREDIT_PACK_1000: ("TURBOPACK compile-time value", "test") || '',
    CREDIT_PACK_2500: ("TURBOPACK compile-time value", "test") || '',
    CREDIT_PACK_5000: ("TURBOPACK compile-time value", "test") || ''
};
const CREDIT_PACKS = [
    {
        id: 'credits-1000',
        name: '1000 Credits',
        description: 'Top up with a small credit pack',
        amount: 1000,
        price: 1000,
        priceId: STRIPE_PRICE_IDS.CREDIT_PACK_1000
    },
    {
        id: 'credits-2500',
        name: '2500 Credits',
        description: 'Best value for regular users',
        amount: 2500,
        price: 2500,
        priceId: STRIPE_PRICE_IDS.CREDIT_PACK_2500
    },
    {
        id: 'credits-5000',
        name: '5000 Credits',
        description: 'Best value for power users',
        amount: 5000,
        price: 5000,
        priceId: STRIPE_PRICE_IDS.CREDIT_PACK_5000
    }
];
// Check if price IDs are configured
const isPricingConfigured = ()=>{
    return STRIPE_PRICE_IDS.PRO_MONTHLY && STRIPE_PRICE_IDS.PRO_YEARLY && STRIPE_PRICE_IDS.BUSINESS_MONTHLY && STRIPE_PRICE_IDS.BUSINESS_YEARLY;
};
// Show warning if price IDs are not configured in production
if (("TURBOPACK compile-time value", "development") === 'production' && !isPricingConfigured()) {
    "TURBOPACK unreachable";
}
const PRICING_TIERS = [
    {
        id: 'free',
        name: 'Free',
        description: 'Essential features for individuals',
        credits: 500,
        features: [
            'Basic dashboard access',
            'Limited access to features',
            'Community support',
            '500 credits per month'
        ],
        popular: false,
        pricing: {
            monthly: {
                priceId: null,
                amount: null
            },
            yearly: {
                priceId: null,
                amount: null
            }
        }
    },
    {
        id: 'pro',
        name: 'Pro',
        description: 'Perfect for professionals',
        credits: 3000,
        features: [
            'Everything in Free',
            'Advanced features',
            'Priority support',
            'Extended usage limits',
            '3000 credits per month'
        ],
        popular: true,
        pricing: {
            monthly: {
                priceId: STRIPE_PRICE_IDS.PRO_MONTHLY || null,
                amount: 2900
            },
            yearly: {
                priceId: STRIPE_PRICE_IDS.PRO_YEARLY || null,
                amount: 29000,
                discount: 16
            }
        }
    },
    {
        id: 'business',
        name: 'Business',
        description: 'For teams and organizations',
        credits: 6000,
        features: [
            'Everything in Pro',
            'Enterprise features',
            'Dedicated support',
            'Custom integrations',
            'Team management',
            '6000 credits per month'
        ],
        popular: false,
        pricing: {
            monthly: {
                priceId: STRIPE_PRICE_IDS.BUSINESS_MONTHLY || null,
                amount: 5900
            },
            yearly: {
                priceId: STRIPE_PRICE_IDS.BUSINESS_YEARLY || null,
                amount: 59000,
                discount: 16
            }
        }
    }
];
function getTierById(id) {
    return PRICING_TIERS.find((tier)=>tier.id === id);
}
const PRICE_ID_MAP = {};
// Populate the price ID map
PRICING_TIERS.forEach((tier)=>{
    // Add monthly price ID if exists
    if (tier.pricing.monthly.priceId) {
        PRICE_ID_MAP[tier.pricing.monthly.priceId] = {
            tierId: tier.id,
            interval: 'monthly'
        };
    }
    // Add yearly price ID if exists
    if (tier.pricing.yearly.priceId) {
        PRICE_ID_MAP[tier.pricing.yearly.priceId] = {
            tierId: tier.id,
            interval: 'yearly'
        };
    }
});
function getTierByPriceId(priceId) {
    if (!priceId) {
        // Default to free tier with no interval
        const freeTier = getTierById('free');
        return {
            tier: freeTier,
            interval: undefined
        };
    }
    const priceInfo = PRICE_ID_MAP[priceId];
    if (!priceInfo) {
        // Price ID not found in our configuration
        return {
            tier: undefined,
            interval: undefined
        };
    }
    const tier = getTierById(priceInfo.tierId);
    return {
        tier,
        interval: priceInfo.interval
    };
}
}}),
"[project]/apps/web/src/lib/credits.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/lib/credits.ts
__turbopack_context__.s({
    "addPurchasedCredits": (()=>addPurchasedCredits),
    "getCreditsByTier": (()=>getCreditsByTier),
    "getUserCredits": (()=>getUserCredits),
    "initializeUserCredits": (()=>initializeUserCredits),
    "resetSubscriptionCredits": (()=>resetSubscriptionCredits),
    "useCredits": (()=>useCredits)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/packages/supabase/src/lib/server.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$web$2f$src$2f$lib$2f$config$2f$pricing$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/web/src/lib/config/pricing.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/packages/supabase/src/lib/admin.ts [app-route] (ecmascript)");
;
;
;
;
function getCreditsByTier(tier) {
    const tierData = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$web$2f$src$2f$lib$2f$config$2f$pricing$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PRICING_TIERS"].find((t)=>t.id === tier);
    return tierData?.credits || 0;
}
const getUserCredits = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cache"])(async ()=>{
    const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
    // Get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
        return {
            subscriptionCredits: 0,
            purchasedCredits: 0,
            total: 0
        };
    }
    // Fetch user credits
    const { data: userData, error: userDataError } = await supabase.from('users').select('subscription_credits, purchased_credits').eq('id', user.id).single();
    if (userDataError || !userData) {
        console.error('Error fetching user credits:', userDataError?.message);
        return {
            subscriptionCredits: 0,
            purchasedCredits: 0,
            total: 0
        };
    }
    const subscriptionCredits = userData.subscription_credits || 0;
    const purchasedCredits = userData.purchased_credits || 0;
    return {
        subscriptionCredits,
        purchasedCredits,
        total: subscriptionCredits + purchasedCredits
    };
});
async function resetSubscriptionCredits(userId, tier) {
    const creditAmount = getCreditsByTier(tier);
    console.log(`Resetting subscription credits for user ${userId} to ${creditAmount} (${tier} tier)`);
    const { error } = await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('users').update({
        subscription_credits: creditAmount,
        last_credits_reset_date: new Date().toISOString()
    }).eq('id', userId);
    if (error) {
        console.error('Error resetting subscription credits:', error.message);
        return false;
    }
    console.log(`Successfully reset credits to ${creditAmount} for user ${userId}`);
    return true;
}
async function addPurchasedCredits(userId, amount) {
    // Get current purchased credits
    const { data: userData, error: fetchError } = await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('users').select('purchased_credits').eq('id', userId).single();
    if (fetchError) {
        console.error('Error fetching user data:', fetchError.message);
        return false;
    }
    const currentCredits = userData?.purchased_credits || 0;
    const newTotal = currentCredits + amount;
    console.log(`Updating user ${userId} from ${currentCredits} to ${newTotal} purchased credits`);
    // Update purchased credits
    const { error: updateError } = await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('users').update({
        purchased_credits: newTotal
    }).eq('id', userId);
    if (updateError) {
        console.error('Error updating purchased credits:', updateError.message);
        return false;
    }
    console.log(`Successfully updated credits to ${newTotal}`);
    return true;
}
async function useCredits(userId, amount, description = '') {
    const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
    // Get current credits
    const { data: userData, error: fetchError } = await supabase.from('users').select('subscription_credits, purchased_credits').eq('id', userId).single();
    if (fetchError) {
        console.error('Error fetching user credits:', fetchError.message);
        return false;
    }
    const subscriptionCredits = userData?.subscription_credits || 0;
    const purchasedCredits = userData?.purchased_credits || 0;
    // Check if user has enough credits
    if (subscriptionCredits + purchasedCredits < amount) {
        return false; // Not enough credits
    }
    // Use subscription credits first
    let remainingAmount = amount;
    let newSubscriptionCredits = subscriptionCredits;
    let newPurchasedCredits = purchasedCredits;
    if (subscriptionCredits >= remainingAmount) {
        newSubscriptionCredits -= remainingAmount;
        remainingAmount = 0;
    } else {
        remainingAmount -= subscriptionCredits;
        newSubscriptionCredits = 0;
        // Use purchased credits for the remainder
        newPurchasedCredits -= remainingAmount;
    }
    // Update credits using admin client for more reliable updates
    const { error: updateError } = await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('users').update({
        subscription_credits: newSubscriptionCredits,
        purchased_credits: newPurchasedCredits
    }).eq('id', userId);
    if (updateError) {
        console.error('Error updating credits:', updateError.message);
        return false;
    }
    // Record usage
    const { error: usageError } = await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('credit_usage').insert({
        user_id: userId,
        amount,
        description
    });
    if (usageError) {
        console.error('Error recording credit usage:', usageError.message);
    }
    return true;
}
async function initializeUserCredits(userId) {
    // Free tier credits by default
    const initialCredits = getCreditsByTier('free');
    console.log(`Initializing credits for new user ${userId} with ${initialCredits} credits`);
    const { error } = await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('users').update({
        subscription_credits: initialCredits,
        purchased_credits: 0,
        last_credits_reset_date: new Date().toISOString()
    }).eq('id', userId);
    if (error) {
        console.error('Error initializing user credits:', error.message);
        return false;
    }
    console.log(`Successfully initialized ${initialCredits} credits for user ${userId}`);
    return true;
}
}}),
"[project]/packages/supabase/src/lib/admin.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/lib/supabase/admin.ts
__turbopack_context__.s({
    "createOrRetrieveCustomer": (()=>createOrRetrieveCustomer),
    "deletePriceRecord": (()=>deletePriceRecord),
    "deleteProductRecord": (()=>deleteProductRecord),
    "manageSubscriptionStatusChange": (()=>manageSubscriptionStatusChange),
    "supabaseAdmin": (()=>supabaseAdmin),
    "upsertPriceRecord": (()=>upsertPriceRecord),
    "upsertProductRecord": (()=>upsertProductRecord)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stripe/esm/stripe.esm.node.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$web$2f$src$2f$lib$2f$credits$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/web/src/lib/credits.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$web$2f$src$2f$lib$2f$config$2f$pricing$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/web/src/lib/config/pricing.ts [app-route] (ecmascript)");
;
;
;
;
const supabaseAdmin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(("TURBOPACK compile-time value", "https://eskcmosgdvrkultpuljo.supabase.co"), process.env.SUPABASE_SERVICE_ROLE_KEY);
// Initialize Stripe
const stripe = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](process.env.STRIPE_SECRET_KEY, {
    apiVersion: '2025-03-31.basil'
});
async function createOrRetrieveCustomer({ uuid, email }) {
    const { data: existingCustomer, error: customerError } = await supabaseAdmin.from('customers').select('stripe_customer_id').eq('id', uuid).single();
    if (existingCustomer?.stripe_customer_id) {
        return existingCustomer.stripe_customer_id;
    }
    // Create a new customer in Stripe
    const customer = await stripe.customers.create({
        email,
        metadata: {
            supabaseUUID: uuid
        }
    });
    // Insert the customer into our database
    const { error } = await supabaseAdmin.from('customers').insert([
        {
            id: uuid,
            stripe_customer_id: customer.id
        }
    ]);
    if (error) throw error;
    return customer.id;
}
async function upsertProductRecord(product) {
    const { error } = await supabaseAdmin.from('products').upsert([
        {
            id: product.id,
            active: product.active,
            name: product.name,
            description: product.description ?? null,
            image: product.images?.[0] ?? null,
            metadata: product.metadata
        }
    ]);
    if (error) throw error;
    console.log(`Product inserted/updated: ${product.id}`);
}
async function deleteProductRecord(productId) {
    const { error } = await supabaseAdmin.from('products').delete().eq('id', productId);
    if (error) throw error;
    console.log(`Product deleted: ${productId}`);
}
async function upsertPriceRecord(price) {
    // Extract interval details
    const interval = price.recurring?.interval;
    const intervalCount = price.recurring?.interval_count ?? null;
    // Extract price type
    const type = price.type;
    const { error } = await supabaseAdmin.from('prices').upsert([
        {
            id: price.id,
            product_id: typeof price.product === 'string' ? price.product : '',
            active: price.active,
            currency: price.currency,
            description: price.nickname ?? null,
            type,
            unit_amount: price.unit_amount ?? null,
            interval,
            interval_count: intervalCount,
            trial_period_days: price.recurring?.trial_period_days ?? null,
            metadata: price.metadata
        }
    ]);
    if (error) throw error;
    console.log(`Price inserted/updated: ${price.id}`);
}
async function deletePriceRecord(priceId) {
    const { error } = await supabaseAdmin.from('prices').delete().eq('id', priceId);
    if (error) throw error;
    console.log(`Price deleted: ${priceId}`);
}
async function manageSubscriptionStatusChange(subscriptionId, customerId, createAction = false) {
    try {
        // Get customer's UUID from mapping table
        const { data: customerData, error: customerError } = await supabaseAdmin.from('customers').select('id').eq('stripe_customer_id', customerId).single();
        if (customerError || !customerData?.id) {
            console.error(`Customer not found: ${customerId}`);
            throw new Error(`Customer not found: ${customerId}`);
        }
        const { id: uuid } = customerData;
        // Retrieve subscription details from Stripe
        const stripeSubscription = await stripe.subscriptions.retrieve(subscriptionId, {
            expand: [
                'default_payment_method',
                'items.data.price',
                'items.data.price.product'
            ]
        });
        // Handle as plain object to avoid TypeScript issues
        const subscription = stripeSubscription;
        // Get the price and product details from the subscription
        const priceId = subscription.items.data[0].price.id;
        const price = subscription.items.data[0].price;
        const product = subscription.items.data[0].price.product;
        // Check if the price exists in our database
        const { data: existingPrice } = await supabaseAdmin.from('prices').select('id').eq('id', priceId).maybeSingle();
        // If price doesn't exist, insert both the product and price first
        if (!existingPrice) {
            console.log(`Price ${priceId} not found in database. Adding to database first...`);
            // First check if the product exists
            const { data: existingProduct } = await supabaseAdmin.from('products').select('id').eq('id', product.id).maybeSingle();
            // Insert product if it doesn't exist
            if (!existingProduct) {
                console.log(`Product ${product.id} not found. Adding product...`);
                await supabaseAdmin.from('products').upsert([
                    {
                        id: product.id,
                        active: product.active,
                        name: product.name,
                        description: product.description ?? null,
                        image: product.images?.[0] ?? null,
                        metadata: product.metadata
                    }
                ]);
            }
            // Then insert the price
            console.log(`Adding price ${priceId}...`);
            await supabaseAdmin.from('prices').upsert([
                {
                    id: priceId,
                    product_id: product.id,
                    active: price.active,
                    currency: price.currency,
                    description: price.nickname ?? null,
                    type: price.type,
                    unit_amount: price.unit_amount ?? null,
                    interval: price.recurring?.interval ?? null,
                    interval_count: price.recurring?.interval_count ?? null,
                    trial_period_days: price.recurring?.trial_period_days ?? null,
                    metadata: price.metadata
                }
            ]);
        }
        // Define helper function inline
        const safeToISOString = (timestamp)=>{
            if (timestamp === null || timestamp === undefined) return null;
            try {
                return new Date(timestamp * 1000).toISOString();
            } catch (error) {
                console.error(`Invalid timestamp: ${timestamp}`, error);
                return null;
            }
        };
        // Current time as fallback
        const now = new Date().toISOString();
        // Upsert the subscription in the database
        const subscriptionData = {
            id: subscription.id,
            user_id: uuid,
            status: subscription.status,
            metadata: subscription.metadata,
            price_id: priceId,
            quantity: subscription.items.data[0].quantity,
            cancel_at_period_end: subscription.cancel_at_period_end,
            cancel_at: subscription.cancel_at ? safeToISOString(subscription.cancel_at) : null,
            canceled_at: subscription.canceled_at ? safeToISOString(subscription.canceled_at) : null,
            current_period_start: safeToISOString(subscription.current_period_start) || now,
            current_period_end: safeToISOString(subscription.current_period_end) || now,
            created: safeToISOString(subscription.created) || now,
            ended_at: subscription.ended_at ? safeToISOString(subscription.ended_at) : null,
            trial_start: subscription.trial_start ? safeToISOString(subscription.trial_start) : null,
            trial_end: subscription.trial_end ? safeToISOString(subscription.trial_end) : null
        };
        console.log(`Upserting subscription ${subscription.id} for user ${uuid}`);
        const { error } = await supabaseAdmin.from('subscriptions').upsert([
            subscriptionData
        ]);
        if (error) {
            console.error(`Supabase subscription upsert error:`, error);
            throw error;
        }
        console.log(`Subscription ${subscription.id} successfully updated for user ${uuid}`);
        // After subscription is processed, reset subscription credits based on tier
        if (subscription.status === 'active' || subscription.status === 'trialing') {
            // Get the product details to determine the tier
            const { tier } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$web$2f$src$2f$lib$2f$config$2f$pricing$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getTierByPriceId"])(priceId);
            if (tier) {
                console.log(`Resetting credits for user ${uuid} to tier ${tier.id} level`);
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$web$2f$src$2f$lib$2f$credits$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resetSubscriptionCredits"])(uuid, tier.id);
            }
        }
        return subscription;
    } catch (error) {
        console.error('Error in manageSubscriptionStatusChange:', error);
        throw error;
    }
}
}}),
"[project]/apps/web/src/app/api/webhooks/pixio/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/app/api/webhooks/pixio/route.ts
__turbopack_context__.s({
    "OPTIONS": (()=>OPTIONS),
    "POST": (()=>POST)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/packages/supabase/src/lib/admin.ts [app-route] (ecmascript)");
;
;
async function POST(req) {
    console.log('[Pixio Webhook] Received webhook request');
    try {
        // Parse the webhook payload
        const payload = await req.json();
        console.log('[Pixio Webhook] Payload:', JSON.stringify(payload, null, 2));
        const { run_id, status, outputs, error: apiError } = payload;
        // Validate required fields
        if (!run_id || !status) {
            console.error('[Pixio Webhook] Missing required fields:', {
                run_id,
                status
            });
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Missing required fields: run_id and status'
            }, {
                status: 400
            });
        }
        // Find the media record by run_id stored in metadata
        console.log('[Pixio Webhook] Looking up media record for run_id:', run_id);
        const { data: mediaRecord, error: fetchError } = await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('generated_media').select('*').eq('metadata->>run_id', run_id).single();
        if (fetchError || !mediaRecord) {
            console.error('[Pixio Webhook] Media record not found for run_id:', run_id, fetchError);
            // Still return 200 to acknowledge webhook receipt
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                received: true,
                warning: 'Media record not found'
            });
        }
        console.log('[Pixio Webhook] Found media record:', mediaRecord.id);
        // Handle different status updates
        if (status === 'processing' || status === 'pending') {
            // Update status only
            console.log(`[Pixio Webhook] Updating status to ${status} for media:`, mediaRecord.id);
            const { error: updateError } = await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('generated_media').update({
                status
            }).eq('id', mediaRecord.id);
            if (updateError) {
                console.error('[Pixio Webhook] Error updating status:', updateError);
                throw updateError;
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                received: true,
                status
            });
        }
        if (status === 'success') {
            console.log('[Pixio Webhook] Processing successful generation for media:', mediaRecord.id);
            // Extract output URL from payload - Pixio uses different structures for different models
            let outputUrl;
            if (outputs && outputs.length > 0) {
                const firstOutput = outputs[0];
                // Try files array (for videos like Wan 2.2)
                if (firstOutput.data?.files && Array.isArray(firstOutput.data.files) && firstOutput.data.files.length > 0) {
                    outputUrl = firstOutput.data.files[0].url;
                } else if (firstOutput.data?.images && Array.isArray(firstOutput.data.images) && firstOutput.data.images.length > 0) {
                    outputUrl = firstOutput.data.images[0].url;
                } else if (firstOutput.url) {
                    outputUrl = firstOutput.url;
                }
            }
            console.log('[Pixio Webhook] Extracted output URL:', outputUrl);
            console.log('[Pixio Webhook] Full outputs:', JSON.stringify(outputs, null, 2));
            if (!outputUrl) {
                console.error('[Pixio Webhook] No output URL in successful webhook. Full outputs:', JSON.stringify(outputs, null, 2));
                // Mark as failed since we can't retrieve the result
                await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('generated_media').update({
                    status: 'failed',
                    metadata: {
                        ...mediaRecord.metadata,
                        error: 'No output URL provided in webhook',
                        failed_at: new Date().toISOString()
                    }
                }).eq('id', mediaRecord.id);
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    received: true,
                    error: 'No output URL'
                });
            }
            try {
                // Download the media from Pixio's output URL
                console.log('[Pixio Webhook] Downloading media from:', outputUrl);
                const mediaResponse = await fetch(outputUrl, {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                });
                if (!mediaResponse.ok) {
                    throw new Error(`Failed to download media: ${mediaResponse.statusText}`);
                }
                const mediaBuffer = await mediaResponse.arrayBuffer();
                const contentSize = mediaBuffer.byteLength;
                console.log(`[Pixio Webhook] Downloaded media size: ${(contentSize / 1024).toFixed(2)} KB`);
                if (contentSize === 0) {
                    throw new Error('Downloaded file is empty');
                }
                // Determine file extension and content type
                const urlExtension = outputUrl.match(/\.(png|jpg|jpeg|webp|gif|mp4)$/i)?.[0]?.toLowerCase();
                let fileExtension;
                let contentType;
                switch(mediaRecord.media_type){
                    case 'image':
                        fileExtension = urlExtension || '.png';
                        contentType = `image/${fileExtension.substring(1)}`;
                        break;
                    case 'video':
                        if (urlExtension === '.mp4') {
                            fileExtension = '.mp4';
                            contentType = 'video/mp4';
                        } else {
                            fileExtension = '.webp';
                            contentType = 'video/webm';
                        }
                        break;
                    default:
                        fileExtension = urlExtension || '.bin';
                        contentType = 'application/octet-stream';
                }
                // Generate storage path
                const timestamp = Date.now();
                const fileName = `${timestamp}-${mediaRecord.id.substring(0, 8)}${fileExtension}`;
                const storagePath = `${mediaRecord.user_id}/${mediaRecord.media_type}s/${fileName}`;
                console.log('[Pixio Webhook] Uploading to Supabase storage:', storagePath);
                // Upload to Supabase Storage
                const { data: uploadData, error: uploadError } = await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].storage.from('generated-media').upload(storagePath, mediaBuffer, {
                    contentType,
                    upsert: true,
                    cacheControl: '3600'
                });
                if (uploadError) {
                    throw new Error(`Storage upload error: ${uploadError.message}`);
                }
                console.log('[Pixio Webhook] Upload successful:', uploadData?.path);
                // Get public URL
                const { data: publicUrlData } = __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].storage.from('generated-media').getPublicUrl(storagePath);
                if (!publicUrlData?.publicUrl) {
                    throw new Error('Failed to get public URL after upload');
                }
                // Update database record with completed status
                const existingMetadata = mediaRecord.metadata && typeof mediaRecord.metadata === 'object' ? mediaRecord.metadata : {};
                const updatePayload = {
                    status: 'completed',
                    media_url: publicUrlData.publicUrl,
                    storage_path: storagePath,
                    metadata: {
                        ...existingMetadata,
                        original_url: outputUrl,
                        file_size: contentSize,
                        completed_at: new Date().toISOString(),
                        error: undefined
                    }
                };
                const { error: finalUpdateError } = await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('generated_media').update(updatePayload).eq('id', mediaRecord.id);
                if (finalUpdateError) {
                    console.error('[Pixio Webhook] Error updating final record:', finalUpdateError);
                    throw finalUpdateError;
                }
                console.log('[Pixio Webhook] Successfully processed media:', mediaRecord.id);
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    received: true,
                    status: 'completed',
                    mediaId: mediaRecord.id
                });
            } catch (processingError) {
                console.error('[Pixio Webhook] Error processing successful result:', processingError);
                // Update record as failed if processing failed
                const existingMetadata = mediaRecord.metadata && typeof mediaRecord.metadata === 'object' ? mediaRecord.metadata : {};
                await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('generated_media').update({
                    status: 'failed',
                    metadata: {
                        ...existingMetadata,
                        error: `Processing error: ${processingError.message}`,
                        failed_at: new Date().toISOString()
                    }
                }).eq('id', mediaRecord.id);
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    received: true,
                    error: processingError.message
                });
            }
        }
        if (status === 'failed' || status === 'cancelled') {
            console.log(`[Pixio Webhook] Updating media to ${status}:`, mediaRecord.id);
            const existingMetadata = mediaRecord.metadata && typeof mediaRecord.metadata === 'object' ? mediaRecord.metadata : {};
            const { error: updateError } = await __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$supabase$2f$src$2f$lib$2f$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabaseAdmin"].from('generated_media').update({
                status: status === 'cancelled' ? 'failed' : status,
                metadata: {
                    ...existingMetadata,
                    error: apiError || (status === 'cancelled' ? 'Generation cancelled' : 'Generation failed'),
                    failed_at: new Date().toISOString(),
                    final_api_status: status
                }
            }).eq('id', mediaRecord.id);
            if (updateError) {
                console.error('[Pixio Webhook] Error updating to failed status:', updateError);
                throw updateError;
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                received: true,
                status
            });
        }
        // Unknown status
        console.warn('[Pixio Webhook] Unknown status received:', status);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            received: true,
            warning: `Unknown status: ${status}`
        });
    } catch (error) {
        console.error('[Pixio Webhook] Error processing webhook:', error);
        // Return 200 to prevent webhook retries for our application errors
        // Log the error but acknowledge receipt
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            received: true,
            error: error.message
        }, {
            status: 200
        });
    }
}
async function OPTIONS() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({}, {
        headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'POST, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization'
        }
    });
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__606f041d._.js.map